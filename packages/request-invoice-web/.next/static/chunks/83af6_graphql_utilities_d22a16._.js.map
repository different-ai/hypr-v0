{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/valueFromASTUntyped.mjs"],"sourcesContent":["import { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { Kind } from '../language/kinds.mjs';\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value\n * will reflect the provided GraphQL value AST.\n *\n * | GraphQL Value        | JavaScript Value |\n * | -------------------- | ---------------- |\n * | Input Object         | Object           |\n * | List                 | Array            |\n * | Boolean              | Boolean          |\n * | String / Enum        | String           |\n * | Int / Float          | Number           |\n * | Null                 | null             |\n *\n */\n\nexport function valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n\n    case Kind.LIST:\n      return valueNode.values.map((node) =>\n        valueFromASTUntyped(node, variables),\n      );\n\n    case Kind.OBJECT:\n      return keyValMap(\n        valueNode.fields,\n        (field) => field.name.value,\n        (field) => valueFromASTUntyped(field.value, variables),\n      );\n\n    case Kind.VARIABLE:\n      return variables === null || variables === void 0\n        ? void 0\n        : variables[valueNode.name.value];\n  }\n}\n"],"names":[],"mappings":";;;AACA;AADA;;;AAmBO,SAAS,oBAAoB,SAAS,EAAE,SAAS;IACtD,OAAQ,UAAU,IAAI;QACpB,KAAK,qMAAA,CAAA,OAAI,CAAC,IAAI;YACZ,OAAO;QAET,KAAK,qMAAA,CAAA,OAAI,CAAC,GAAG;YACX,OAAO,SAAS,UAAU,KAAK,EAAE;QAEnC,KAAK,qMAAA,CAAA,OAAI,CAAC,KAAK;YACb,OAAO,WAAW,UAAU,KAAK;QAEnC,KAAK,qMAAA,CAAA,OAAI,CAAC,MAAM;QAChB,KAAK,qMAAA,CAAA,OAAI,CAAC,IAAI;QACd,KAAK,qMAAA,CAAA,OAAI,CAAC,OAAO;YACf,OAAO,UAAU,KAAK;QAExB,KAAK,qMAAA,CAAA,OAAI,CAAC,IAAI;YACZ,OAAO,UAAU,MAAM,CAAC,GAAG,CAAC,CAAC,OAC3B,oBAAoB,MAAM;QAG9B,KAAK,qMAAA,CAAA,OAAI,CAAC,MAAM;YACd,OAAO,CAAA,GAAA,wMAAA,CAAA,YAAS,AAAD,EACb,UAAU,MAAM,EAChB,CAAC,QAAU,MAAM,IAAI,CAAC,KAAK,EAC3B,CAAC,QAAU,oBAAoB,MAAM,KAAK,EAAE;QAGhD,KAAK,qMAAA,CAAA,OAAI,CAAC,QAAQ;YAChB,OAAO,cAAc,QAAQ,cAAc,KAAK,IAC5C,KAAK,IACL,SAAS,CAAC,UAAU,IAAI,CAAC,KAAK,CAAC;IACvC;AACF","ignoreList":[0]}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/astFromValue.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n} from '../type/definition.mjs';\nimport { GraphQLID } from '../type/scalars.mjs';\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using suggested GraphQLInputType. For example:\n *\n *     astFromValue(\"value\", GraphQLString)\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | Unknown       | Enum Value           |\n * | null          | NullValue            |\n *\n */\n\nexport function astFromValue(value, type) {\n  if (isNonNullType(type)) {\n    const astValue = astFromValue(value, type.ofType);\n\n    if (\n      (astValue === null || astValue === void 0 ? void 0 : astValue.kind) ===\n      Kind.NULL\n    ) {\n      return null;\n    }\n\n    return astValue;\n  } // only explicit null, not undefined, NaN\n\n  if (value === null) {\n    return {\n      kind: Kind.NULL,\n    };\n  } // undefined\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n  if (isListType(type)) {\n    const itemType = type.ofType;\n\n    if (isIterableObject(value)) {\n      const valuesNodes = [];\n\n      for (const item of value) {\n        const itemNode = astFromValue(item, itemType);\n\n        if (itemNode != null) {\n          valuesNodes.push(itemNode);\n        }\n      }\n\n      return {\n        kind: Kind.LIST,\n        values: valuesNodes,\n      };\n    }\n\n    return astFromValue(value, itemType);\n  } // Populate the fields of the input object by creating ASTs from each value\n  // in the JavaScript object according to the fields in the input type.\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(value)) {\n      return null;\n    }\n\n    const fieldNodes = [];\n\n    for (const field of Object.values(type.getFields())) {\n      const fieldValue = astFromValue(value[field.name], field.type);\n\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: Kind.OBJECT_FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: field.name,\n          },\n          value: fieldValue,\n        });\n      }\n    }\n\n    return {\n      kind: Kind.OBJECT,\n      fields: fieldNodes,\n    };\n  }\n\n  if (isLeafType(type)) {\n    // Since value is an internally represented value, it must be serialized\n    // to an externally represented value before converting into an AST.\n    const serialized = type.serialize(value);\n\n    if (serialized == null) {\n      return null;\n    } // Others serialize based on their corresponding JavaScript scalar types.\n\n    if (typeof serialized === 'boolean') {\n      return {\n        kind: Kind.BOOLEAN,\n        value: serialized,\n      };\n    } // JavaScript numbers can be Int or Float values.\n\n    if (typeof serialized === 'number' && Number.isFinite(serialized)) {\n      const stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum)\n        ? {\n            kind: Kind.INT,\n            value: stringNum,\n          }\n        : {\n            kind: Kind.FLOAT,\n            value: stringNum,\n          };\n    }\n\n    if (typeof serialized === 'string') {\n      // Enum types use Enum literals.\n      if (isEnumType(type)) {\n        return {\n          kind: Kind.ENUM,\n          value: serialized,\n        };\n      } // ID types can use Int literals.\n\n      if (type === GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: Kind.INT,\n          value: serialized,\n        };\n      }\n\n      return {\n        kind: Kind.STRING,\n        value: serialized,\n      };\n    }\n\n    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/sortValueNode.mjs"],"sourcesContent":["import { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport { Kind } from '../language/kinds.mjs';\n/**\n * Sort ValueNode.\n *\n * This function returns a sorted copy of the given ValueNode.\n *\n * @internal\n */\n\nexport function sortValueNode(valueNode) {\n  switch (valueNode.kind) {\n    case Kind.OBJECT:\n      return { ...valueNode, fields: sortFields(valueNode.fields) };\n\n    case Kind.LIST:\n      return { ...valueNode, values: valueNode.values.map(sortValueNode) };\n\n    case Kind.INT:\n    case Kind.FLOAT:\n    case Kind.STRING:\n    case Kind.BOOLEAN:\n    case Kind.NULL:\n    case Kind.ENUM:\n    case Kind.VARIABLE:\n      return valueNode;\n  }\n}\n\nfunction sortFields(fields) {\n  return fields\n    .map((fieldNode) => ({\n      ...fieldNode,\n      value: sortValueNode(fieldNode.value),\n    }))\n    .sort((fieldA, fieldB) =>\n      naturalCompare(fieldA.name.value, fieldB.name.value),\n    );\n}\n"],"names":[],"mappings":";;;AACA;AADA;;;AAUO,SAAS,cAAc,SAAS;IACrC,OAAQ,UAAU,IAAI;QACpB,KAAK,qMAAA,CAAA,OAAI,CAAC,MAAM;YACd,OAAO;gBAAE,GAAG,SAAS;gBAAE,QAAQ,WAAW,UAAU,MAAM;YAAE;QAE9D,KAAK,qMAAA,CAAA,OAAI,CAAC,IAAI;YACZ,OAAO;gBAAE,GAAG,SAAS;gBAAE,QAAQ,UAAU,MAAM,CAAC,GAAG,CAAC;YAAe;QAErE,KAAK,qMAAA,CAAA,OAAI,CAAC,GAAG;QACb,KAAK,qMAAA,CAAA,OAAI,CAAC,KAAK;QACf,KAAK,qMAAA,CAAA,OAAI,CAAC,MAAM;QAChB,KAAK,qMAAA,CAAA,OAAI,CAAC,OAAO;QACjB,KAAK,qMAAA,CAAA,OAAI,CAAC,IAAI;QACd,KAAK,qMAAA,CAAA,OAAI,CAAC,IAAI;QACd,KAAK,qMAAA,CAAA,OAAI,CAAC,QAAQ;YAChB,OAAO;IACX;AACF;AAEA,SAAS,WAAW,MAAM;IACxB,OAAO,OACJ,GAAG,CAAC,CAAC,YAAc,CAAC;YACnB,GAAG,SAAS;YACZ,OAAO,cAAc,UAAU,KAAK;QACtC,CAAC,GACA,IAAI,CAAC,CAAC,QAAQ,SACb,CAAA,GAAA,6MAAA,CAAA,iBAAc,AAAD,EAAE,OAAO,IAAI,CAAC,KAAK,EAAE,OAAO,IAAI,CAAC,KAAK;AAEzD","ignoreList":[0]}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/findBreakingChanges.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nvar BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport { BreakingChangeType };\nvar DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n\nexport { DangerousChangeType };\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (isListType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      (isNonNullType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    (isNamedType(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    (isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      isListType(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, ({ name }) => name);\n  const newMap = keyMap(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 587, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 593, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/typeFromAST.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { GraphQLList, GraphQLNonNull } from '../type/definition.mjs';\nexport function typeFromAST(schema, typeNode) {\n  switch (typeNode.kind) {\n    case Kind.LIST_TYPE: {\n      const innerType = typeFromAST(schema, typeNode.type);\n      return innerType && new GraphQLList(innerType);\n    }\n\n    case Kind.NON_NULL_TYPE: {\n      const innerType = typeFromAST(schema, typeNode.type);\n      return innerType && new GraphQLNonNull(innerType);\n    }\n\n    case Kind.NAMED_TYPE:\n      return schema.getType(typeNode.name.value);\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AACO,SAAS,YAAY,MAAM,EAAE,QAAQ;IAC1C,OAAQ,SAAS,IAAI;QACnB,KAAK,qMAAA,CAAA,OAAI,CAAC,SAAS;YAAE;gBACnB,MAAM,YAAY,YAAY,QAAQ,SAAS,IAAI;gBACnD,OAAO,aAAa,IAAI,sMAAA,CAAA,cAAW,CAAC;YACtC;QAEA,KAAK,qMAAA,CAAA,OAAI,CAAC,aAAa;YAAE;gBACvB,MAAM,YAAY,YAAY,QAAQ,SAAS,IAAI;gBACnD,OAAO,aAAa,IAAI,sMAAA,CAAA,iBAAc,CAAC;YACzC;QAEA,KAAK,qMAAA,CAAA,OAAI,CAAC,UAAU;YAClB,OAAO,OAAO,OAAO,CAAC,SAAS,IAAI,CAAC,KAAK;IAC7C;AACF","ignoreList":[0]}},
    {"offset": {"line": 616, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/typeComparators.mjs"],"sourcesContent":["import {\n  isAbstractType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.mjs';\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nexport function isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n  if (isNonNullType(typeA) && isNonNullType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n  if (isListType(typeA) && isListType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nexport function isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n  if (isNonNullType(superType)) {\n    if (isNonNullType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isNonNullType(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n  if (isListType(superType)) {\n    if (isListType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isListType(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n  return (\n    isAbstractType(superType) &&\n    (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) &&\n    schema.isSubType(superType, maybeSubType)\n  );\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\nexport function doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if (isAbstractType(typeA)) {\n    if (isAbstractType(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema\n        .getPossibleTypes(typeA)\n        .some((type) => schema.isSubType(typeB, type));\n    } // Determine if the latter type is a possible concrete type of the former.\n\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if (isAbstractType(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n  return false;\n}\n"],"names":[],"mappings":";;;;;AAAA;;AAWO,SAAS,YAAY,KAAK,EAAE,KAAK;IACtC,8BAA8B;IAC9B,IAAI,UAAU,OAAO;QACnB,OAAO;IACT,EAAE,+DAA+D;IAEjE,IAAI,CAAA,GAAA,sMAAA,CAAA,gBAAa,AAAD,EAAE,UAAU,CAAA,GAAA,sMAAA,CAAA,gBAAa,AAAD,EAAE,QAAQ;QAChD,OAAO,YAAY,MAAM,MAAM,EAAE,MAAM,MAAM;IAC/C,EAAE,2DAA2D;IAE7D,IAAI,CAAA,GAAA,sMAAA,CAAA,aAAU,AAAD,EAAE,UAAU,CAAA,GAAA,sMAAA,CAAA,aAAU,AAAD,EAAE,QAAQ;QAC1C,OAAO,YAAY,MAAM,MAAM,EAAE,MAAM,MAAM;IAC/C,EAAE,qCAAqC;IAEvC,OAAO;AACT;AAMO,SAAS,gBAAgB,MAAM,EAAE,YAAY,EAAE,SAAS;IAC7D,qCAAqC;IACrC,IAAI,iBAAiB,WAAW;QAC9B,OAAO;IACT,EAAE,gEAAgE;IAElE,IAAI,CAAA,GAAA,sMAAA,CAAA,gBAAa,AAAD,EAAE,YAAY;QAC5B,IAAI,CAAA,GAAA,sMAAA,CAAA,gBAAa,AAAD,EAAE,eAAe;YAC/B,OAAO,gBAAgB,QAAQ,aAAa,MAAM,EAAE,UAAU,MAAM;QACtE;QAEA,OAAO;IACT;IAEA,IAAI,CAAA,GAAA,sMAAA,CAAA,gBAAa,AAAD,EAAE,eAAe;QAC/B,sEAAsE;QACtE,OAAO,gBAAgB,QAAQ,aAAa,MAAM,EAAE;IACtD,EAAE,sEAAsE;IAExE,IAAI,CAAA,GAAA,sMAAA,CAAA,aAAU,AAAD,EAAE,YAAY;QACzB,IAAI,CAAA,GAAA,sMAAA,CAAA,aAAU,AAAD,EAAE,eAAe;YAC5B,OAAO,gBAAgB,QAAQ,aAAa,MAAM,EAAE,UAAU,MAAM;QACtE;QAEA,OAAO;IACT;IAEA,IAAI,CAAA,GAAA,sMAAA,CAAA,aAAU,AAAD,EAAE,eAAe;QAC5B,oEAAoE;QACpE,OAAO;IACT,EAAE,oFAAoF;IACtF,uEAAuE;IAEvE,OACE,CAAA,GAAA,sMAAA,CAAA,iBAAc,AAAD,EAAE,cACf,CAAC,CAAA,GAAA,sMAAA,CAAA,kBAAe,AAAD,EAAE,iBAAiB,CAAA,GAAA,sMAAA,CAAA,eAAY,AAAD,EAAE,aAAa,KAC5D,OAAO,SAAS,CAAC,WAAW;AAEhC;AAWO,SAAS,eAAe,MAAM,EAAE,KAAK,EAAE,KAAK;IACjD,2BAA2B;IAC3B,IAAI,UAAU,OAAO;QACnB,OAAO;IACT;IAEA,IAAI,CAAA,GAAA,sMAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ;QACzB,IAAI,CAAA,GAAA,sMAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ;YACzB,0EAA0E;YAC1E,2CAA2C;YAC3C,OAAO,OACJ,gBAAgB,CAAC,OACjB,IAAI,CAAC,CAAC,OAAS,OAAO,SAAS,CAAC,OAAO;QAC5C,EAAE,0EAA0E;QAE5E,OAAO,OAAO,SAAS,CAAC,OAAO;IACjC;IAEA,IAAI,CAAA,GAAA,sMAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ;QACzB,0EAA0E;QAC1E,OAAO,OAAO,SAAS,CAAC,OAAO;IACjC,EAAE,sCAAsC;IAExC,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 689, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 695, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/valueFromAST.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n} from '../type/definition.mjs';\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Unknown       |\n * | NullValue            | null          |\n *\n */\n\nexport function valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (valueNode.kind === Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n\n    if (variables == null || variables[variableName] === undefined) {\n      // No valid return value.\n      return;\n    }\n\n    const variableValue = variables[variableName];\n\n    if (variableValue === null && isNonNullType(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n    return variableValue;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    const itemType = type.ofType;\n\n    if (valueNode.kind === Kind.LIST) {\n      const coercedValues = [];\n\n      for (const itemNode of valueNode.values) {\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          const itemValue = valueFromAST(itemNode, itemType, variables);\n\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    const coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    const coercedObj = Object.create(null);\n    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);\n\n    for (const field of Object.values(type.getFields())) {\n      const fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  }\n\n  if (isLeafType(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    let result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible input types have been considered.\n\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return (\n    valueNode.kind === Kind.VARIABLE &&\n    (variables == null || variables[valueNode.name.value] === undefined)\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 814, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 820, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/coerceInputValue.mjs"],"sourcesContent":["import { didYouMean } from '../jsutils/didYouMean.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { suggestionList } from '../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport {\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n} from '../type/definition.mjs';\n\n/**\n * Coerces a JavaScript value given a GraphQL Input Type.\n */\nexport function coerceInputValue(inputValue, type, onError = defaultOnError) {\n  return coerceInputValueImpl(inputValue, type, onError, undefined);\n}\n\nfunction defaultOnError(path, invalidValue, error) {\n  let errorPrefix = 'Invalid value ' + inspect(invalidValue);\n\n  if (path.length > 0) {\n    errorPrefix += ` at \"value${printPathArray(path)}\"`;\n  }\n\n  error.message = errorPrefix + ': ' + error.message;\n  throw error;\n}\n\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\n  if (isNonNullType(type)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\n    }\n\n    onError(\n      pathToArray(path),\n      inputValue,\n      new GraphQLError(\n        `Expected non-nullable type \"${inspect(type)}\" not to be null.`,\n      ),\n    );\n    return;\n  }\n\n  if (inputValue == null) {\n    // Explicitly return the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    const itemType = type.ofType;\n\n    if (isIterableObject(inputValue)) {\n      return Array.from(inputValue, (itemValue, index) => {\n        const itemPath = addPath(path, index, undefined);\n        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\n      });\n    } // Lists accept a non-list value as a list of one.\n\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\n  }\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(inputValue)) {\n      onError(\n        pathToArray(path),\n        inputValue,\n        new GraphQLError(`Expected type \"${type.name}\" to be an object.`),\n      );\n      return;\n    }\n\n    const coercedValue = {};\n    const fieldDefs = type.getFields();\n\n    for (const field of Object.values(fieldDefs)) {\n      const fieldValue = inputValue[field.name];\n\n      if (fieldValue === undefined) {\n        if (field.defaultValue !== undefined) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          const typeStr = inspect(field.type);\n          onError(\n            pathToArray(path),\n            inputValue,\n            new GraphQLError(\n              `Field \"${field.name}\" of required type \"${typeStr}\" was not provided.`,\n            ),\n          );\n        }\n\n        continue;\n      }\n\n      coercedValue[field.name] = coerceInputValueImpl(\n        fieldValue,\n        field.type,\n        onError,\n        addPath(path, field.name, type.name),\n      );\n    } // Ensure every provided field is defined.\n\n    for (const fieldName of Object.keys(inputValue)) {\n      if (!fieldDefs[fieldName]) {\n        const suggestions = suggestionList(\n          fieldName,\n          Object.keys(type.getFields()),\n        );\n        onError(\n          pathToArray(path),\n          inputValue,\n          new GraphQLError(\n            `Field \"${fieldName}\" is not defined by type \"${type.name}\".` +\n              didYouMean(suggestions),\n          ),\n        );\n      }\n    }\n\n    return coercedValue;\n  }\n\n  if (isLeafType(type)) {\n    let parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\n    // which can throw to indicate failure. If it throws, maintain a reference\n    // to the original error.\n\n    try {\n      parseResult = type.parseValue(inputValue);\n    } catch (error) {\n      if (error instanceof GraphQLError) {\n        onError(pathToArray(path), inputValue, error);\n      } else {\n        onError(\n          pathToArray(path),\n          inputValue,\n          new GraphQLError(`Expected type \"${type.name}\". ` + error.message, {\n            originalError: error,\n          }),\n        );\n      }\n\n      return;\n    }\n\n    if (parseResult === undefined) {\n      onError(\n        pathToArray(path),\n        inputValue,\n        new GraphQLError(`Expected type \"${type.name}\".`),\n      );\n    }\n\n    return parseResult;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 930, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 936, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/TypeInfo.mjs"],"sourcesContent":["import { isNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { getEnterLeaveForKind } from '../language/visitor.mjs';\nimport {\n  getNamedType,\n  getNullableType,\n  isCompositeType,\n  isEnumType,\n  isInputObjectType,\n  isInputType,\n  isInterfaceType,\n  isListType,\n  isObjectType,\n  isOutputType,\n} from '../type/definition.mjs';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from '../type/introspection.mjs';\nimport { typeFromAST } from './typeFromAST.mjs';\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport class TypeInfo {\n  constructor(\n    schema,\n    /**\n     * Initial type may be provided in rare cases to facilitate traversals\n     *  beginning somewhere other than documents.\n     */\n    initialType,\n    /** @deprecated will be removed in 17.0.0 */\n    getFieldDefFn,\n  ) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef =\n      getFieldDefFn !== null && getFieldDefFn !== void 0\n        ? getFieldDefFn\n        : getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'TypeInfo';\n  }\n\n  getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  }\n\n  getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  }\n\n  getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  }\n\n  getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  }\n\n  getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  }\n\n  getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  }\n\n  getDirective() {\n    return this._directive;\n  }\n\n  getArgument() {\n    return this._argument;\n  }\n\n  getEnumValue() {\n    return this._enumValue;\n  }\n\n  enter(node) {\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET: {\n        const namedType = getNamedType(this.getType());\n\n        this._parentTypeStack.push(\n          isCompositeType(namedType) ? namedType : undefined,\n        );\n\n        break;\n      }\n\n      case Kind.FIELD: {\n        const parentType = this.getParentType();\n        let fieldDef;\n        let fieldType;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n        break;\n      }\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION: {\n        const rootType = schema.getRootType(node.operation);\n\n        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);\n\n        break;\n      }\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION: {\n        const typeConditionAST = node.typeCondition;\n        const outputType = typeConditionAST\n          ? typeFromAST(schema, typeConditionAST)\n          : getNamedType(this.getType());\n\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n        break;\n      }\n\n      case Kind.VARIABLE_DEFINITION: {\n        const inputType = typeFromAST(schema, node.type);\n\n        this._inputTypeStack.push(\n          isInputType(inputType) ? inputType : undefined,\n        );\n\n        break;\n      }\n\n      case Kind.ARGUMENT: {\n        var _this$getDirective;\n\n        let argDef;\n        let argType;\n        const fieldOrDirective =\n          (_this$getDirective = this.getDirective()) !== null &&\n          _this$getDirective !== void 0\n            ? _this$getDirective\n            : this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = fieldOrDirective.args.find(\n            (arg) => arg.name === node.name.value,\n          );\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n        break;\n      }\n\n      case Kind.LIST: {\n        const listType = getNullableType(this.getInputType());\n        const itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n        this._defaultValueStack.push(undefined);\n\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n        break;\n      }\n\n      case Kind.OBJECT_FIELD: {\n        const objectType = getNamedType(this.getInputType());\n        let inputFieldType;\n        let inputField;\n\n        if (isInputObjectType(objectType)) {\n          inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._defaultValueStack.push(\n          inputField ? inputField.defaultValue : undefined,\n        );\n\n        this._inputTypeStack.push(\n          isInputType(inputFieldType) ? inputFieldType : undefined,\n        );\n\n        break;\n      }\n\n      case Kind.ENUM: {\n        const enumType = getNamedType(this.getInputType());\n        let enumValue;\n\n        if (isEnumType(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n      }\n\n      default: // Ignore other nodes\n    }\n  }\n\n  leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n\n      default: // Ignore other nodes\n    }\n  }\n}\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const name = fieldNode.name.value;\n\n  if (\n    name === SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter(...args) {\n      const node = args[0];\n      typeInfo.enter(node);\n      const fn = getEnterLeaveForKind(visitor, node.kind).enter;\n\n      if (fn) {\n        const result = fn.apply(visitor, args);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n\n    leave(...args) {\n      const node = args[0];\n      const fn = getEnterLeaveForKind(visitor, node.kind).leave;\n      let result;\n\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    },\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1209, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1215, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/assertValidName.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { assertName } from '../type/assertName.mjs';\n/* c8 ignore start */\n\n/**\n * Upholds the spec rules about naming.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function assertValidName(name) {\n  const error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function isValidNameError(name) {\n  typeof name === 'string' || devAssert(false, 'Expected name to be a string.');\n\n  if (name.startsWith('__')) {\n    return new GraphQLError(\n      `Name \"${name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n    );\n  }\n\n  try {\n    assertName(name);\n  } catch (error) {\n    return error;\n  }\n}\n/* c8 ignore stop */\n"],"names":[],"mappings":";;;;AAAA;AAEA;AADA;;;;AASO,SAAS,gBAAgB,IAAI;IAClC,MAAM,QAAQ,iBAAiB;IAE/B,IAAI,OAAO;QACT,MAAM;IACR;IAEA,OAAO;AACT;AAMO,SAAS,iBAAiB,IAAI;IACnC,OAAO,SAAS,YAAY,CAAA,GAAA,wMAAA,CAAA,YAAS,AAAD,EAAE,OAAO;IAE7C,IAAI,KAAK,UAAU,CAAC,OAAO;QACzB,OAAO,IAAI,yMAAA,CAAA,eAAY,CACrB,CAAC,MAAM,EAAE,KAAK,uEAAuE,CAAC;IAE1F;IAEA,IAAI;QACF,CAAA,GAAA,sMAAA,CAAA,aAAU,AAAD,EAAE;IACb,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF,EACA,kBAAkB","ignoreList":[0]}},
    {"offset": {"line": 1243, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1249, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/extendSchema.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../language/predicates.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport {\n  GraphQLDeprecatedDirective,\n  GraphQLDirective,\n  GraphQLSpecifiedByDirective,\n} from '../type/directives.mjs';\nimport {\n  introspectionTypes,\n  isIntrospectionType,\n} from '../type/introspection.mjs';\nimport {\n  isSpecifiedScalarType,\n  specifiedScalarTypes,\n} from '../type/scalars.mjs';\nimport { assertSchema, GraphQLSchema } from '../type/schema.mjs';\nimport { assertValidSDLExtension } from '../validation/validate.mjs';\nimport { getDirectiveValues } from '../execution/values.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  (documentAST != null && documentAST.kind === Kind.DOCUMENT) ||\n    devAssert(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig\n    ? schema\n    : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n\n  for (const def of documentAST.definitions) {\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions\n        ? existingTypeExtensions.concat([def])\n        : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (\n    Object.keys(typeExtensionsMap).length === 0 &&\n    typeDefs.length === 0 &&\n    directiveDefs.length === 0 &&\n    schemaExtensions.length === 0 &&\n    schemaDef == null\n  ) {\n    return schemaConfig;\n  }\n\n  const typeMap = Object.create(null);\n\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n\n    const name = typeNode.name.value;\n    typeMap[name] =\n      (_stdTypeMap$name = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name !== void 0\n        ? _stdTypeMap$name\n        : buildType(typeNode);\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription:\n      schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions),\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description:\n      (_schemaDef = schemaDef) === null || _schemaDef === void 0\n        ? void 0\n        : (_schemaDef$descriptio = _schemaDef.description) === null ||\n          _schemaDef$descriptio === void 0\n        ? void 0\n        : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [\n      ...schemaConfig.directives.map(replaceDirective),\n      ...directiveDefs.map(buildDirective),\n    ],\n    extensions: Object.create(null),\n    astNode:\n      (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0\n        ? _schemaDef2\n        : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid:\n      (_options$assumeValid =\n        options === null || options === void 0\n          ? void 0\n          : options.assumeValid) !== null && _options$assumeValid !== void 0\n        ? _options$assumeValid\n        : false,\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      args: mapValue(config.args, extendArg),\n    });\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    }\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co !== void 0\n        ? _typeExtensionsMap$co\n        : [];\n    return new GraphQLInputObjectType({\n      ...config,\n      fields: () => ({\n        ...mapValue(config.fields, (field) => ({\n          ...field,\n          type: replaceType(field.type),\n        })),\n        ...buildInputFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null &&\n      _typeExtensionsMap$ty !== void 0\n        ? _typeExtensionsMap$ty\n        : [];\n    return new GraphQLEnumType({\n      ...config,\n      values: { ...config.values, ...buildEnumValueMap(extensions) },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co2 !== void 0\n        ? _typeExtensionsMap$co2\n        : [];\n    let specifiedByURL = config.specifiedByURL;\n\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n\n      specifiedByURL =\n        (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null &&\n        _getSpecifiedByURL !== void 0\n          ? _getSpecifiedByURL\n          : specifiedByURL;\n    }\n\n    return new GraphQLScalarType({\n      ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co3 !== void 0\n        ? _typeExtensionsMap$co3\n        : [];\n    return new GraphQLObjectType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co4 !== void 0\n        ? _typeExtensionsMap$co4\n        : [];\n    return new GraphQLInterfaceType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co5 !== void 0\n        ? _typeExtensionsMap$co5\n        : [];\n    return new GraphQLUnionType({\n      ...config,\n      types: () => [\n        ...type.getTypes().map(replaceNamedType),\n        ...buildUnionTypes(extensions),\n      ],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendField(field) {\n    return {\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && mapValue(field.args, extendArg),\n    };\n  }\n\n  function extendArg(arg) {\n    return { ...arg, type: replaceType(arg.type) };\n  }\n\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n\n    for (const node of nodes) {\n      var _node$operationTypes;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const operationTypesNodes =\n        /* c8 ignore next */\n        (_node$operationTypes = node.operationTypes) !== null &&\n        _node$operationTypes !== void 0\n          ? _node$operationTypes\n          : [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    const name = node.name.value;\n    const type =\n      (_stdTypeMap$name2 = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name2 !== void 0\n        ? _stdTypeMap$name2\n        : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new GraphQLDirective({\n      name: node.name.value,\n      description:\n        (_node$description = node.description) === null ||\n        _node$description === void 0\n          ? void 0\n          : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(({ value }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node,\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const nodeFields =\n        /* c8 ignore next */\n        (_node$fields = node.fields) !== null && _node$fields !== void 0\n          ? _node$fields\n          : [];\n\n      for (const field of nodeFields) {\n        var _field$description;\n\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description:\n            (_field$description = field.description) === null ||\n            _field$description === void 0\n              ? void 0\n              : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    const argsNodes =\n      /* c8 ignore next */\n      args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n\n    for (const arg of argsNodes) {\n      var _arg$description;\n\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description:\n          (_arg$description = arg.description) === null ||\n          _arg$description === void 0\n            ? void 0\n            : _arg$description.value,\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg,\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields2;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const fieldsNodes =\n        /* c8 ignore next */\n        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0\n          ? _node$fields2\n          : [];\n\n      for (const field of fieldsNodes) {\n        var _field$description2;\n\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description:\n            (_field$description2 = field.description) === null ||\n            _field$description2 === void 0\n              ? void 0\n              : _field$description2.value,\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$values;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const valuesNodes =\n        /* c8 ignore next */\n        (_node$values = node.values) !== null && _node$values !== void 0\n          ? _node$values\n          : [];\n\n      for (const value of valuesNodes) {\n        var _value$description;\n\n        enumValueMap[value.name.value] = {\n          description:\n            (_value$description = value.description) === null ||\n            _value$description === void 0\n              ? void 0\n              : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value,\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$interfaces$map, _node$interfaces;\n\n        return (\n          /* c8 ignore next */\n          (_node$interfaces$map =\n            (_node$interfaces = node.interfaces) === null ||\n            _node$interfaces === void 0\n              ? void 0\n              : _node$interfaces.map(getNamedType)) !== null &&\n            _node$interfaces$map !== void 0\n            ? _node$interfaces$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$types$map, _node$types;\n\n        return (\n          /* c8 ignore next */\n          (_node$types$map =\n            (_node$types = node.types) === null || _node$types === void 0\n              ? void 0\n              : _node$types.map(getNamedType)) !== null &&\n            _node$types$map !== void 0\n            ? _node$types$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    const name = astNode.name.value;\n    const extensionASTNodes =\n      (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null &&\n      _typeExtensionsMap$na !== void 0\n        ? _typeExtensionsMap$na\n        : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION: {\n        var _astNode$description;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLObjectType({\n          name,\n          description:\n            (_astNode$description = astNode.description) === null ||\n            _astNode$description === void 0\n              ? void 0\n              : _astNode$description.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INTERFACE_TYPE_DEFINITION: {\n        var _astNode$description2;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInterfaceType({\n          name,\n          description:\n            (_astNode$description2 = astNode.description) === null ||\n            _astNode$description2 === void 0\n              ? void 0\n              : _astNode$description2.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.ENUM_TYPE_DEFINITION: {\n        var _astNode$description3;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLEnumType({\n          name,\n          description:\n            (_astNode$description3 = astNode.description) === null ||\n            _astNode$description3 === void 0\n              ? void 0\n              : _astNode$description3.value,\n          values: buildEnumValueMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.UNION_TYPE_DEFINITION: {\n        var _astNode$description4;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLUnionType({\n          name,\n          description:\n            (_astNode$description4 = astNode.description) === null ||\n            _astNode$description4 === void 0\n              ? void 0\n              : _astNode$description4.value,\n          types: () => buildUnionTypes(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.SCALAR_TYPE_DEFINITION: {\n        var _astNode$description5;\n\n        return new GraphQLScalarType({\n          name,\n          description:\n            (_astNode$description5 = astNode.description) === null ||\n            _astNode$description5 === void 0\n              ? void 0\n              : _astNode$description5.value,\n          specifiedByURL: getSpecifiedByURL(astNode),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n        var _astNode$description6;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInputObjectType({\n          name,\n          description:\n            (_astNode$description6 = astNode.description) === null ||\n            _astNode$description6 === void 0\n              ? void 0\n              : _astNode$description6.value,\n          fields: () => buildInputFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n    }\n  }\n}\nconst stdTypeMap = keyMap(\n  [...specifiedScalarTypes, ...introspectionTypes],\n  (type) => type.name,\n);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0\n    ? void 0\n    : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0\n    ? void 0\n    : specifiedBy.url;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1777, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1783, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/buildASTSchema.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { specifiedDirectives } from '../type/directives.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { assertValidSDL } from '../validation/validate.mjs';\nimport { extendSchemaImpl } from './extendSchema.mjs';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query,\n * Mutation and Subscription.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\nexport function buildASTSchema(documentAST, options) {\n  (documentAST != null && documentAST.kind === Kind.DOCUMENT) ||\n    devAssert(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    assertValidSDL(documentAST);\n  }\n\n  const emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: Object.create(null),\n    extensionASTNodes: [],\n    assumeValid: false,\n  };\n  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (const type of config.types) {\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          // @ts-expect-error validated in `validateSchema`\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          // @ts-expect-error validated in `validateSchema`\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          // @ts-expect-error validated in `validateSchema`\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  const directives = [\n    ...config.directives, // If specified directives were not explicitly declared, add them.\n    ...specifiedDirectives.filter((stdDirective) =>\n      config.directives.every(\n        (directive) => directive.name !== stdDirective.name,\n      ),\n    ),\n  ];\n  return new GraphQLSchema({ ...config, directives });\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  const document = parse(source, {\n    noLocation:\n      options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacyFragmentVariables:\n      options === null || options === void 0\n        ? void 0\n        : options.allowLegacyFragmentVariables,\n  });\n  return buildASTSchema(document, {\n    assumeValidSDL:\n      options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  });\n}\n"],"names":[],"mappings":";;;;AACA;AADA;AAKA;AACA;AAHA;AACA;AAFA;;;;;;;;AAgBO,SAAS,eAAe,WAAW,EAAE,OAAO;IAChD,eAAe,QAAQ,YAAY,IAAI,KAAK,qMAAA,CAAA,OAAI,CAAC,QAAQ,IACxD,CAAA,GAAA,wMAAA,CAAA,YAAS,AAAD,EAAE,OAAO;IAEnB,IACE,CAAC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,WAAW,MACpE,QACF,CAAC,YAAY,QAAQ,YAAY,KAAK,IAClC,KAAK,IACL,QAAQ,cAAc,MAAM,MAChC;QACA,CAAA,GAAA,0MAAA,CAAA,iBAAc,AAAD,EAAE;IACjB;IAEA,MAAM,oBAAoB;QACxB,aAAa;QACb,OAAO,EAAE;QACT,YAAY,EAAE;QACd,YAAY,OAAO,MAAM,CAAC;QAC1B,mBAAmB,EAAE;QACrB,aAAa;IACf;IACA,MAAM,SAAS,CAAA,GAAA,6MAAA,CAAA,mBAAgB,AAAD,EAAE,mBAAmB,aAAa;IAEhE,IAAI,OAAO,OAAO,IAAI,MAAM;QAC1B,KAAK,MAAM,QAAQ,OAAO,KAAK,CAAE;YAC/B,OAAQ,KAAK,IAAI;gBACf,oEAAoE;gBACpE,qEAAqE;gBACrE,yEAAyE;gBACzE,KAAK;oBACH,iDAAiD;oBACjD,OAAO,KAAK,GAAG;oBACf;gBAEF,KAAK;oBACH,iDAAiD;oBACjD,OAAO,QAAQ,GAAG;oBAClB;gBAEF,KAAK;oBACH,iDAAiD;oBACjD,OAAO,YAAY,GAAG;oBACtB;YACJ;QACF;IACF;IAEA,MAAM,aAAa;WACd,OAAO,UAAU;WACjB,sMAAA,CAAA,sBAAmB,CAAC,MAAM,CAAC,CAAC,eAC7B,OAAO,UAAU,CAAC,KAAK,CACrB,CAAC,YAAc,UAAU,IAAI,KAAK,aAAa,IAAI;KAGxD;IACD,OAAO,IAAI,kMAAA,CAAA,gBAAa,CAAC;QAAE,GAAG,MAAM;QAAE;IAAW;AACnD;AAMO,SAAS,YAAY,MAAM,EAAE,OAAO;IACzC,MAAM,WAAW,CAAA,GAAA,sMAAA,CAAA,QAAK,AAAD,EAAE,QAAQ;QAC7B,YACE,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,UAAU;QACtE,8BACE,YAAY,QAAQ,YAAY,KAAK,IACjC,KAAK,IACL,QAAQ,4BAA4B;IAC5C;IACA,OAAO,eAAe,UAAU;QAC9B,gBACE,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,cAAc;QAC1E,aACE,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,WAAW;IACzE;AACF","ignoreList":[0]}},
    {"offset": {"line": 1855, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1861, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/buildClientSchema.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport {\n  assertInterfaceType,\n  assertNullableType,\n  assertObjectType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isInputType,\n  isOutputType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  (isObjectLike(introspection) && isObjectLike(introspection.__schema)) ||\n    devAssert(\n      false,\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(\n        introspection,\n      )}.`,\n    ); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(\n    schemaIntrospection.types,\n    (typeIntrospection) => typeIntrospection.name,\n    (typeIntrospection) => buildType(typeIntrospection),\n  ); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType\n    ? getObjectType(schemaIntrospection.queryType)\n    : null;\n  const mutationType = schemaIntrospection.mutationType\n    ? getObjectType(schemaIntrospection.mutationType)\n    : null;\n  const subscriptionType = schemaIntrospection.subscriptionType\n    ? getObjectType(schemaIntrospection.subscriptionType)\n    : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives\n    ? schemaIntrospection.directives.map(buildDirective)\n    : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\n      );\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = inspect(type);\n    throw new Error(\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\n    );\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL,\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (\n      implementingIntrospection.interfaces === null &&\n      implementingIntrospection.kind === TypeKind.INTERFACE\n    ) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\n      );\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection),\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection),\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(\n        enumIntrospection.enumValues,\n        (valueIntrospection) => valueIntrospection.name,\n        (valueIntrospection) => ({\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason,\n        }),\n      ),\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\n        `Introspection result missing fields: ${inspect(typeIntrospection)}.`,\n      );\n    }\n\n    return keyValMap(\n      typeIntrospection.fields,\n      (fieldIntrospection) => fieldIntrospection.name,\n      buildField,\n    );\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\n      );\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\n      );\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args),\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(\n      inputValueIntrospections,\n      (inputValue) => inputValue.name,\n      buildInputValue,\n    );\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\n      );\n    }\n\n    const defaultValue =\n      inputValueIntrospection.defaultValue != null\n        ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type)\n        : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason,\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args),\n    });\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2102, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2108, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/concatAST.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\n\nexport function concatAST(documents) {\n  const definitions = [];\n\n  for (const doc of documents) {\n    definitions.push(...doc.definitions);\n  }\n\n  return {\n    kind: Kind.DOCUMENT,\n    definitions,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,UAAU,SAAS;IACjC,MAAM,cAAc,EAAE;IAEtB,KAAK,MAAM,OAAO,UAAW;QAC3B,YAAY,IAAI,IAAI,IAAI,WAAW;IACrC;IAEA,OAAO;QACL,MAAM,qMAAA,CAAA,OAAI,CAAC,QAAQ;QACnB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2123, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2129, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/getIntrospectionQuery.mjs"],"sourcesContent":["/**\n * Produce the GraphQL query recommended for a full schema introspection.\n * Accepts optional IntrospectionOptions.\n */\nexport function getIntrospectionQuery(options) {\n  const optionsWithDefault = {\n    descriptions: true,\n    specifiedByUrl: false,\n    directiveIsRepeatable: false,\n    schemaDescription: false,\n    inputValueDeprecation: false,\n    ...options,\n  };\n  const descriptions = optionsWithDefault.descriptions ? 'description' : '';\n  const specifiedByUrl = optionsWithDefault.specifiedByUrl\n    ? 'specifiedByURL'\n    : '';\n  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable\n    ? 'isRepeatable'\n    : '';\n  const schemaDescription = optionsWithDefault.schemaDescription\n    ? descriptions\n    : '';\n\n  function inputDeprecation(str) {\n    return optionsWithDefault.inputValueDeprecation ? str : '';\n  }\n\n  return `\n    query IntrospectionQuery {\n      __schema {\n        ${schemaDescription}\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ${descriptions}\n          ${directiveIsRepeatable}\n          locations\n          args${inputDeprecation('(includeDeprecated: true)')} {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ${descriptions}\n      ${specifiedByUrl}\n      fields(includeDeprecated: true) {\n        name\n        ${descriptions}\n        args${inputDeprecation('(includeDeprecated: true)')} {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields${inputDeprecation('(includeDeprecated: true)')} {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ${descriptions}\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ${descriptions}\n      type { ...TypeRef }\n      defaultValue\n      ${inputDeprecation('isDeprecated')}\n      ${inputDeprecation('deprecationReason')}\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                    ofType {\n                      kind\n                      name\n                      ofType {\n                        kind\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `;\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;AACM,SAAS,sBAAsB,OAAO;IAC3C,MAAM,qBAAqB;QACzB,cAAc;QACd,gBAAgB;QAChB,uBAAuB;QACvB,mBAAmB;QACnB,uBAAuB;QACvB,GAAG,OAAO;IACZ;IACA,MAAM,eAAe,mBAAmB,YAAY,GAAG,gBAAgB;IACvE,MAAM,iBAAiB,mBAAmB,cAAc,GACpD,mBACA;IACJ,MAAM,wBAAwB,mBAAmB,qBAAqB,GAClE,iBACA;IACJ,MAAM,oBAAoB,mBAAmB,iBAAiB,GAC1D,eACA;IAEJ,SAAS,iBAAiB,GAAG;QAC3B,OAAO,mBAAmB,qBAAqB,GAAG,MAAM;IAC1D;IAEA,OAAO,CAAC;;;QAGF,EAAE,kBAAkB;;;;;;;;;UASlB,EAAE,aAAa;UACf,EAAE,sBAAsB;;cAEpB,EAAE,iBAAiB,6BAA6B;;;;;;;;;;MAUxD,EAAE,aAAa;MACf,EAAE,eAAe;;;QAGf,EAAE,aAAa;YACX,EAAE,iBAAiB,6BAA6B;;;;;;;;;iBAS3C,EAAE,iBAAiB,6BAA6B;;;;;;;;QAQzD,EAAE,aAAa;;;;;;;;;;;MAWjB,EAAE,aAAa;;;MAGf,EAAE,iBAAiB,gBAAgB;MACnC,EAAE,iBAAiB,qBAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2C5C,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 2258, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2264, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/getOperationAST.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n\nexport function getOperationAST(documentAST, operationName) {\n  let operation = null;\n\n  for (const definition of documentAST.definitions) {\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (\n        ((_definition$name = definition.name) === null ||\n        _definition$name === void 0\n          ? void 0\n          : _definition$name.value) === operationName\n      ) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,gBAAgB,WAAW,EAAE,aAAa;IACxD,IAAI,YAAY;IAEhB,KAAK,MAAM,cAAc,YAAY,WAAW,CAAE;QAChD,IAAI,WAAW,IAAI,KAAK,qMAAA,CAAA,OAAI,CAAC,oBAAoB,EAAE;YACjD,IAAI;YAEJ,IAAI,iBAAiB,MAAM;gBACzB,uEAAuE;gBACvE,uEAAuE;gBACvE,QAAQ;gBACR,IAAI,WAAW;oBACb,OAAO;gBACT;gBAEA,YAAY;YACd,OAAO,IACL,CAAC,CAAC,mBAAmB,WAAW,IAAI,MAAM,QAC1C,qBAAqB,KAAK,IACtB,KAAK,IACL,iBAAiB,KAAK,MAAM,eAChC;gBACA,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 2289, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2295, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/getOperationRootType.mjs"],"sourcesContent":["import { GraphQLError } from '../error/GraphQLError.mjs';\n\n/**\n * Extracts the root type of the operation from the schema.\n *\n * @deprecated Please use `GraphQLSchema.getRootType` instead. Will be removed in v17\n */\nexport function getOperationRootType(schema, operation) {\n  if (operation.operation === 'query') {\n    const queryType = schema.getQueryType();\n\n    if (!queryType) {\n      throw new GraphQLError(\n        'Schema does not define the required query root type.',\n        {\n          nodes: operation,\n        },\n      );\n    }\n\n    return queryType;\n  }\n\n  if (operation.operation === 'mutation') {\n    const mutationType = schema.getMutationType();\n\n    if (!mutationType) {\n      throw new GraphQLError('Schema is not configured for mutations.', {\n        nodes: operation,\n      });\n    }\n\n    return mutationType;\n  }\n\n  if (operation.operation === 'subscription') {\n    const subscriptionType = schema.getSubscriptionType();\n\n    if (!subscriptionType) {\n      throw new GraphQLError('Schema is not configured for subscriptions.', {\n        nodes: operation,\n      });\n    }\n\n    return subscriptionType;\n  }\n\n  throw new GraphQLError(\n    'Can only have query, mutation and subscription operations.',\n    {\n      nodes: operation,\n    },\n  );\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,qBAAqB,MAAM,EAAE,SAAS;IACpD,IAAI,UAAU,SAAS,KAAK,SAAS;QACnC,MAAM,YAAY,OAAO,YAAY;QAErC,IAAI,CAAC,WAAW;YACd,MAAM,IAAI,yMAAA,CAAA,eAAY,CACpB,wDACA;gBACE,OAAO;YACT;QAEJ;QAEA,OAAO;IACT;IAEA,IAAI,UAAU,SAAS,KAAK,YAAY;QACtC,MAAM,eAAe,OAAO,eAAe;QAE3C,IAAI,CAAC,cAAc;YACjB,MAAM,IAAI,yMAAA,CAAA,eAAY,CAAC,2CAA2C;gBAChE,OAAO;YACT;QACF;QAEA,OAAO;IACT;IAEA,IAAI,UAAU,SAAS,KAAK,gBAAgB;QAC1C,MAAM,mBAAmB,OAAO,mBAAmB;QAEnD,IAAI,CAAC,kBAAkB;YACrB,MAAM,IAAI,yMAAA,CAAA,eAAY,CAAC,+CAA+C;gBACpE,OAAO;YACT;QACF;QAEA,OAAO;IACT;IAEA,MAAM,IAAI,yMAAA,CAAA,eAAY,CACpB,8DACA;QACE,OAAO;IACT;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 2332, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2338, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/introspectionFromSchema.mjs"],"sourcesContent":["import { invariant } from '../jsutils/invariant.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { executeSync } from '../execution/execute.mjs';\nimport { getIntrospectionQuery } from './getIntrospectionQuery.mjs';\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\n\nexport function introspectionFromSchema(schema, options) {\n  const optionsWithDefaults = {\n    specifiedByUrl: true,\n    directiveIsRepeatable: true,\n    schemaDescription: true,\n    inputValueDeprecation: true,\n    ...options,\n  };\n  const document = parse(getIntrospectionQuery(optionsWithDefaults));\n  const result = executeSync({\n    schema,\n    document,\n  });\n  (!result.errors && result.data) || invariant(false);\n  return result.data;\n}\n"],"names":[],"mappings":";;;AACA;AAEA;AADA;AAFA;;;;;AAcO,SAAS,wBAAwB,MAAM,EAAE,OAAO;IACrD,MAAM,sBAAsB;QAC1B,gBAAgB;QAChB,uBAAuB;QACvB,mBAAmB;QACnB,uBAAuB;QACvB,GAAG,OAAO;IACZ;IACA,MAAM,WAAW,CAAA,GAAA,sMAAA,CAAA,QAAK,AAAD,EAAE,CAAA,GAAA,sNAAA,CAAA,wBAAqB,AAAD,EAAE;IAC7C,MAAM,SAAS,CAAA,GAAA,wMAAA,CAAA,cAAW,AAAD,EAAE;QACzB;QACA;IACF;IACC,CAAC,OAAO,MAAM,IAAI,OAAO,IAAI,IAAK,CAAA,GAAA,wMAAA,CAAA,YAAS,AAAD,EAAE;IAC7C,OAAO,OAAO,IAAI;AACpB","ignoreList":[0]}},
    {"offset": {"line": 2365, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2371, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/lexicographicSortSchema.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\n\nexport function lexicographicSortSchema(schema) {\n  const schemaConfig = schema.toConfig();\n  const typeMap = keyValMap(\n    sortByName(schemaConfig.types),\n    (type) => type.name,\n    sortNamedType,\n  );\n  return new GraphQLSchema({\n    ...schemaConfig,\n    types: Object.values(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription),\n  });\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME: TS Conversion\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n\n  function sortDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      locations: sortBy(config.locations, (x) => x),\n      args: sortArgs(config.args),\n    });\n  }\n\n  function sortArgs(args) {\n    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && sortArgs(field.args),\n    }));\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n    }));\n  }\n\n  function sortTypes(array) {\n    return sortByName(array).map(replaceNamedType);\n  }\n\n  function sortNamedType(type) {\n    if (isScalarType(type) || isIntrospectionType(type)) {\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLObjectType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isInterfaceType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInterfaceType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isUnionType(type)) {\n      const config = type.toConfig();\n      return new GraphQLUnionType({\n        ...config,\n        types: () => sortTypes(config.types),\n      });\n    }\n\n    if (isEnumType(type)) {\n      const config = type.toConfig();\n      return new GraphQLEnumType({\n        ...config,\n        values: sortObjMap(config.values, (value) => value),\n      });\n    }\n\n    if (isInputObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInputObjectType({\n        ...config,\n        fields: () => sortInputFields(config.fields),\n      });\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible types have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  const sortedMap = Object.create(null);\n\n  for (const key of Object.keys(map).sort(naturalCompare)) {\n    sortedMap[key] = sortValueFn(map[key]);\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, (obj) => obj.name);\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort((obj1, obj2) => {\n    const key1 = mapToKey(obj1);\n    const key2 = mapToKey(obj2);\n    return naturalCompare(key1, key2);\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2510, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2516, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/printSchema.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isPrintableAsBlockString } from '../language/blockString.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport {\n  DEFAULT_DEPRECATION_REASON,\n  isSpecifiedDirective,\n} from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nexport function printSchema(schema) {\n  return printFilteredSchema(\n    schema,\n    (n) => !isSpecifiedDirective(n),\n    isDefinedType,\n  );\n}\nexport function printIntrospectionSchema(schema) {\n  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);\n}\n\nfunction isDefinedType(type) {\n  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter) {\n  const directives = schema.getDirectives().filter(directiveFilter);\n  const types = Object.values(schema.getTypeMap()).filter(typeFilter);\n  return [\n    printSchemaDefinition(schema),\n    ...directives.map((directive) => printDirective(directive)),\n    ...types.map((type) => printType(type)),\n  ]\n    .filter(Boolean)\n    .join('\\n\\n');\n}\n\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  const operationTypes = [];\n  const queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(`  query: ${queryType.name}`);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(`  mutation: ${mutationType.name}`);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(`  subscription: ${subscriptionType.name}`);\n  }\n\n  return printDescription(schema) + `schema {\\n${operationTypes.join('\\n')}\\n}`;\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n * ```graphql\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *     subscription: Subscription\n *   }\n * ```\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\nfunction isSchemaOfCommonNames(schema) {\n  const queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function printType(type) {\n  if (isScalarType(type)) {\n    return printScalar(type);\n  }\n\n  if (isObjectType(type)) {\n    return printObject(type);\n  }\n\n  if (isInterfaceType(type)) {\n    return printInterface(type);\n  }\n\n  if (isUnionType(type)) {\n    return printUnion(type);\n  }\n\n  if (isEnumType(type)) {\n    return printEnum(type);\n  }\n\n  if (isInputObjectType(type)) {\n    return printInputObject(type);\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction printScalar(type) {\n  return (\n    printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type)\n  );\n}\n\nfunction printImplementedInterfaces(type) {\n  const interfaces = type.getInterfaces();\n  return interfaces.length\n    ? ' implements ' + interfaces.map((i) => i.name).join(' & ')\n    : '';\n}\n\nfunction printObject(type) {\n  return (\n    printDescription(type) +\n    `type ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printInterface(type) {\n  return (\n    printDescription(type) +\n    `interface ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printUnion(type) {\n  const types = type.getTypes();\n  const possibleTypes = types.length ? ' = ' + types.join(' | ') : '';\n  return printDescription(type) + 'union ' + type.name + possibleTypes;\n}\n\nfunction printEnum(type) {\n  const values = type\n    .getValues()\n    .map(\n      (value, i) =>\n        printDescription(value, '  ', !i) +\n        '  ' +\n        value.name +\n        printDeprecated(value.deprecationReason),\n    );\n  return printDescription(type) + `enum ${type.name}` + printBlock(values);\n}\n\nfunction printInputObject(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) => printDescription(f, '  ', !i) + '  ' + printInputValue(f),\n  );\n  return printDescription(type) + `input ${type.name}` + printBlock(fields);\n}\n\nfunction printFields(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) =>\n      printDescription(f, '  ', !i) +\n      '  ' +\n      f.name +\n      printArgs(f.args, '  ') +\n      ': ' +\n      String(f.type) +\n      printDeprecated(f.deprecationReason),\n  );\n  return printBlock(fields);\n}\n\nfunction printBlock(items) {\n  return items.length !== 0 ? ' {\\n' + items.join('\\n') + '\\n}' : '';\n}\n\nfunction printArgs(args, indentation = '') {\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n  if (args.every((arg) => !arg.description)) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return (\n    '(\\n' +\n    args\n      .map(\n        (arg, i) =>\n          printDescription(arg, '  ' + indentation, !i) +\n          '  ' +\n          indentation +\n          printInputValue(arg),\n      )\n      .join('\\n') +\n    '\\n' +\n    indentation +\n    ')'\n  );\n}\n\nfunction printInputValue(arg) {\n  const defaultAST = astFromValue(arg.defaultValue, arg.type);\n  let argDecl = arg.name + ': ' + String(arg.type);\n\n  if (defaultAST) {\n    argDecl += ` = ${print(defaultAST)}`;\n  }\n\n  return argDecl + printDeprecated(arg.deprecationReason);\n}\n\nfunction printDirective(directive) {\n  return (\n    printDescription(directive) +\n    'directive @' +\n    directive.name +\n    printArgs(directive.args) +\n    (directive.isRepeatable ? ' repeatable' : '') +\n    ' on ' +\n    directive.locations.join(' | ')\n  );\n}\n\nfunction printDeprecated(reason) {\n  if (reason == null) {\n    return '';\n  }\n\n  if (reason !== DEFAULT_DEPRECATION_REASON) {\n    const astValue = print({\n      kind: Kind.STRING,\n      value: reason,\n    });\n    return ` @deprecated(reason: ${astValue})`;\n  }\n\n  return ' @deprecated';\n}\n\nfunction printSpecifiedByURL(scalar) {\n  if (scalar.specifiedByURL == null) {\n    return '';\n  }\n\n  const astValue = print({\n    kind: Kind.STRING,\n    value: scalar.specifiedByURL,\n  });\n  return ` @specifiedBy(url: ${astValue})`;\n}\n\nfunction printDescription(def, indentation = '', firstInBlock = true) {\n  const { description } = def;\n\n  if (description == null) {\n    return '';\n  }\n\n  const blockString = print({\n    kind: Kind.STRING,\n    value: description,\n    block: isPrintableAsBlockString(description),\n  });\n  const prefix =\n    indentation && !firstInBlock ? '\\n' + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, '\\n' + indentation) + '\\n';\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2718, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2724, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/separateOperations.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAQO,SAAS,mBAAmB,WAAW;IAC5C,MAAM,aAAa,EAAE;IACrB,MAAM,WAAW,OAAO,MAAM,CAAC,OAAO,kDAAkD;IAExF,KAAK,MAAM,kBAAkB,YAAY,WAAW,CAAE;QACpD,OAAQ,eAAe,IAAI;YACzB,KAAK,qMAAA,CAAA,OAAI,CAAC,oBAAoB;gBAC5B,WAAW,IAAI,CAAC;gBAChB;YAEF,KAAK,qMAAA,CAAA,OAAI,CAAC,mBAAmB;gBAC3B,QAAQ,CAAC,eAAe,IAAI,CAAC,KAAK,CAAC,GAAG,oBACpC,eAAe,YAAY;gBAE7B;YAEF;QACF;IACF,EAAE,6EAA6E;IAC/E,8CAA8C;IAE9C,MAAM,wBAAwB,OAAO,MAAM,CAAC;IAE5C,KAAK,MAAM,aAAa,WAAY;QAClC,MAAM,eAAe,IAAI;QAEzB,KAAK,MAAM,gBAAgB,oBAAoB,UAAU,YAAY,EAAG;YACtE,8BAA8B,cAAc,UAAU;QACxD,EAAE,sDAAsD;QAExD,MAAM,gBAAgB,UAAU,IAAI,GAAG,UAAU,IAAI,CAAC,KAAK,GAAG,IAAI,yEAAyE;QAC3I,qDAAqD;QAErD,qBAAqB,CAAC,cAAc,GAAG;YACrC,MAAM,qMAAA,CAAA,OAAI,CAAC,QAAQ;YACnB,aAAa,YAAY,WAAW,CAAC,MAAM,CACzC,CAAC,OACC,SAAS,aACR,KAAK,IAAI,KAAK,qMAAA,CAAA,OAAI,CAAC,mBAAmB,IACrC,aAAa,GAAG,CAAC,KAAK,IAAI,CAAC,KAAK;QAExC;IACF;IAEA,OAAO;AACT;AAEA,yEAAyE;AACzE,wCAAwC;AACxC,SAAS,8BAA8B,SAAS,EAAE,QAAQ,EAAE,QAAQ;IAClE,IAAI,CAAC,UAAU,GAAG,CAAC,WAAW;QAC5B,UAAU,GAAG,CAAC;QACd,MAAM,gBAAgB,QAAQ,CAAC,SAAS;QAExC,IAAI,kBAAkB,WAAW;YAC/B,KAAK,MAAM,UAAU,cAAe;gBAClC,8BAA8B,WAAW,UAAU;YACrD;QACF;IACF;AACF;AAEA,SAAS,oBAAoB,YAAY;IACvC,MAAM,eAAe,EAAE;IACvB,CAAA,GAAA,uMAAA,CAAA,QAAK,AAAD,EAAE,cAAc;QAClB,gBAAe,IAAI;YACjB,aAAa,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK;QACnC;IACF;IACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 2783, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2789, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/utilities/stripIgnoredCharacters.mjs"],"sourcesContent":["import { printBlockString } from '../language/blockString.mjs';\nimport { isPunctuatorTokenKind, Lexer } from '../language/lexer.mjs';\nimport { isSource, Source } from '../language/source.mjs';\nimport { TokenKind } from '../language/tokenKind.mjs';\n/**\n * Strips characters that are not significant to the validity or execution\n * of a GraphQL document:\n *   - UnicodeBOM\n *   - WhiteSpace\n *   - LineTerminator\n *   - Comment\n *   - Comma\n *   - BlockString indentation\n *\n * Note: It is required to have a delimiter character between neighboring\n * non-punctuator tokens and this function always uses single space as delimiter.\n *\n * It is guaranteed that both input and output documents if parsed would result\n * in the exact same AST except for nodes location.\n *\n * Warning: It is guaranteed that this function will always produce stable results.\n * However, it's not guaranteed that it will stay the same between different\n * releases due to bugfixes or changes in the GraphQL specification.\n *\n * Query example:\n *\n * ```graphql\n * query SomeQuery($foo: String!, $bar: String) {\n *   someField(foo: $foo, bar: $bar) {\n *     a\n *     b {\n *       c\n *       d\n *     }\n *   }\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}\n * ```\n *\n * SDL example:\n *\n * ```graphql\n * \"\"\"\n * Type description\n * \"\"\"\n * type Foo {\n *   \"\"\"\n *   Field description\n *   \"\"\"\n *   bar: String\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * \"\"\"Type description\"\"\" type Foo{\"\"\"Field description\"\"\" bar:String}\n * ```\n */\n\nexport function stripIgnoredCharacters(source) {\n  const sourceObj = isSource(source) ? source : new Source(source);\n  const body = sourceObj.body;\n  const lexer = new Lexer(sourceObj);\n  let strippedBody = '';\n  let wasLastAddedTokenNonPunctuator = false;\n\n  while (lexer.advance().kind !== TokenKind.EOF) {\n    const currentToken = lexer.token;\n    const tokenKind = currentToken.kind;\n    /**\n     * Every two non-punctuator tokens should have space between them.\n     * Also prevent case of non-punctuator token following by spread resulting\n     * in invalid token (e.g. `1...` is invalid Float token).\n     */\n\n    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);\n\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {\n        strippedBody += ' ';\n      }\n    }\n\n    const tokenBody = body.slice(currentToken.start, currentToken.end);\n\n    if (tokenKind === TokenKind.BLOCK_STRING) {\n      strippedBody += printBlockString(currentToken.value, {\n        minimize: true,\n      });\n    } else {\n      strippedBody += tokenBody;\n    }\n\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n\n  return strippedBody;\n}\n"],"names":[],"mappings":";;;AAEA;AADA;AAEA;AAHA;;;;;AAiEO,SAAS,uBAAuB,MAAM;IAC3C,MAAM,YAAY,CAAA,GAAA,sMAAA,CAAA,WAAQ,AAAD,EAAE,UAAU,SAAS,IAAI,sMAAA,CAAA,SAAM,CAAC;IACzD,MAAM,OAAO,UAAU,IAAI;IAC3B,MAAM,QAAQ,IAAI,qMAAA,CAAA,QAAK,CAAC;IACxB,IAAI,eAAe;IACnB,IAAI,iCAAiC;IAErC,MAAO,MAAM,OAAO,GAAG,IAAI,KAAK,yMAAA,CAAA,YAAS,CAAC,GAAG,CAAE;QAC7C,MAAM,eAAe,MAAM,KAAK;QAChC,MAAM,YAAY,aAAa,IAAI;QACnC;;;;KAIC,GAED,MAAM,kBAAkB,CAAC,CAAA,GAAA,qMAAA,CAAA,wBAAqB,AAAD,EAAE,aAAa,IAAI;QAEhE,IAAI,gCAAgC;YAClC,IAAI,mBAAmB,aAAa,IAAI,KAAK,yMAAA,CAAA,YAAS,CAAC,MAAM,EAAE;gBAC7D,gBAAgB;YAClB;QACF;QAEA,MAAM,YAAY,KAAK,KAAK,CAAC,aAAa,KAAK,EAAE,aAAa,GAAG;QAEjE,IAAI,cAAc,yMAAA,CAAA,YAAS,CAAC,YAAY,EAAE;YACxC,gBAAgB,CAAA,GAAA,2MAAA,CAAA,mBAAgB,AAAD,EAAE,aAAa,KAAK,EAAE;gBACnD,UAAU;YACZ;QACF,OAAO;YACL,gBAAgB;QAClB;QAEA,iCAAiC;IACnC;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 2831, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}