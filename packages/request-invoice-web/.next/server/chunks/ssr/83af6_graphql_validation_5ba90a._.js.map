{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isExecutableDefinitionNode } from '../../language/predicates.mjs';\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n *\n * See https://spec.graphql.org/draft/#sec-Executable-Definitions\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document(node) {\n      for (const definition of node.definitions) {\n        if (!isExecutableDefinitionNode(definition)) {\n          const defName =\n            definition.kind === Kind.SCHEMA_DEFINITION ||\n            definition.kind === Kind.SCHEMA_EXTENSION\n              ? 'schema'\n              : '\"' + definition.name.value + '\"';\n          context.reportError(\n            new GraphQLError(`The ${defName} definition is not executable.`, {\n              nodes: definition,\n            }),\n          );\n        }\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAEA;AADA;AADA;;;;AAYO,SAAS,0BAA0B,OAAO;IAC/C,OAAO;QACL,UAAS,IAAI;YACX,KAAK,MAAM,cAAc,KAAK,WAAW,CAAE;gBACzC,IAAI,CAAC,CAAA,GAAA,uMAAA,CAAA,6BAA0B,AAAD,EAAE,aAAa;oBAC3C,MAAM,UACJ,WAAW,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,iBAAiB,IAC1C,WAAW,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,gBAAgB,GACrC,WACA,MAAM,WAAW,IAAI,CAAC,KAAK,GAAG;oBACpC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CAAC,CAAC,IAAI,EAAE,QAAQ,8BAA8B,CAAC,EAAE;wBAC/D,OAAO;oBACT;gBAEJ;YACF;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { naturalCompare } from '../../jsutils/naturalCompare.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = didYouMean(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n        return -1;\n      }\n\n      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n        return 1;\n      }\n\n      return naturalCompare(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          const typeStr = print(typeCondition);\n          context.reportError(\n            new GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        const typeStr = print(node.typeCondition);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAGA;AADA;AADA;AADA;;;;;AAcO,SAAS,8BAA8B,OAAO;IACnD,OAAO;QACL,gBAAe,IAAI;YACjB,MAAM,gBAAgB,KAAK,aAAa;YAExC,IAAI,eAAe;gBACjB,MAAM,OAAO,CAAA,GAAA,yMAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI;gBAE9C,IAAI,QAAQ,CAAC,CAAA,GAAA,mMAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;oBAClC,MAAM,UAAU,CAAA,GAAA,oMAAA,CAAA,QAAK,AAAD,EAAE;oBACtB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,iDAAiD,EAAE,QAAQ,EAAE,CAAC,EAC/D;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;QAEA,oBAAmB,IAAI;YACrB,MAAM,OAAO,CAAA,GAAA,yMAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI,KAAK,aAAa;YAEhE,IAAI,QAAQ,CAAC,CAAA,GAAA,mMAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;gBAClC,MAAM,UAAU,CAAA,GAAA,oMAAA,CAAA,QAAK,AAAD,EAAE,KAAK,aAAa;gBACxC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,UAAU,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,0CAA0C,EAAE,QAAQ,EAAE,CAAC,EACpF;oBACE,OAAO,KAAK,aAAa;gBAC3B;YAGN;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n * See https://spec.graphql.org/draft/#sec-Directives-Are-In-Valid-Locations\n */\nexport function KnownArgumentNamesRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...KnownArgumentNamesOnDirectivesRule(context),\n\n    Argument(argNode) {\n      const argDef = context.getArgument();\n      const fieldDef = context.getFieldDef();\n      const parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        const argName = argNode.name.value;\n        const knownArgsNames = fieldDef.args.map((arg) => arg.name);\n        const suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(\n          new GraphQLError(\n            `Unknown argument \"${argName}\" on field \"${parentType.name}.${fieldDef.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: argNode,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  const directiveArgs = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argsNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);\n    }\n  }\n\n  return {\n    Directive(directiveNode) {\n      const directiveName = directiveNode.name.value;\n      const knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (const argNode of directiveNode.arguments) {\n          const argName = argNode.name.value;\n\n          if (!knownArgs.includes(argName)) {\n            const suggestions = suggestionList(argName, knownArgs);\n            context.reportError(\n              new GraphQLError(\n                `Unknown argument \"${argName}\" on directive \"@${directiveName}\".` +\n                  didYouMean(suggestions),\n                {\n                  nodes: argNode,\n                },\n              ),\n            );\n          }\n        }\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AAFA;AAIA;AADA;;;;;;AAYO,SAAS,uBAAuB,OAAO;IAC5C,OAAO;QACL,mCAAmC;QACnC,GAAG,mCAAmC,QAAQ;QAE9C,UAAS,OAAO;YACd,MAAM,SAAS,QAAQ,WAAW;YAClC,MAAM,WAAW,QAAQ,WAAW;YACpC,MAAM,aAAa,QAAQ,aAAa;YAExC,IAAI,CAAC,UAAU,YAAY,YAAY;gBACrC,MAAM,UAAU,QAAQ,IAAI,CAAC,KAAK;gBAClC,MAAM,iBAAiB,SAAS,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI;gBAC1D,MAAM,cAAc,CAAA,GAAA,0MAAA,CAAA,iBAAc,AAAD,EAAE,SAAS;gBAC5C,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,kBAAkB,EAAE,QAAQ,YAAY,EAAE,WAAW,IAAI,CAAC,CAAC,EAAE,SAAS,IAAI,CAAC,EAAE,CAAC,GAC7E,CAAA,GAAA,sMAAA,CAAA,aAAU,AAAD,EAAE,cACb;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF;AAKO,SAAS,mCAAmC,OAAO;IACxD,MAAM,gBAAgB,OAAO,MAAM,CAAC;IACpC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,oBAAoB,SACtB,OAAO,aAAa,KACpB,mMAAA,CAAA,sBAAmB;IAEvB,KAAK,MAAM,aAAa,kBAAmB;QACzC,aAAa,CAAC,UAAU,IAAI,CAAC,GAAG,UAAU,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI;IACtE;IAEA,MAAM,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAExD,KAAK,MAAM,OAAO,eAAgB;QAChC,IAAI,IAAI,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,oBAAoB,EAAE;YAC1C,IAAI;YAEJ,2DAA2D;YAE3D,kBAAkB,GAClB,MAAM,YACJ,CAAC,iBAAiB,IAAI,SAAS,MAAM,QAAQ,mBAAmB,KAAK,IACjE,iBACA,EAAE;YACR,aAAa,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QACvE;IACF;IAEA,OAAO;QACL,WAAU,aAAa;YACrB,MAAM,gBAAgB,cAAc,IAAI,CAAC,KAAK;YAC9C,MAAM,YAAY,aAAa,CAAC,cAAc;YAE9C,IAAI,cAAc,SAAS,IAAI,WAAW;gBACxC,KAAK,MAAM,WAAW,cAAc,SAAS,CAAE;oBAC7C,MAAM,UAAU,QAAQ,IAAI,CAAC,KAAK;oBAElC,IAAI,CAAC,UAAU,QAAQ,CAAC,UAAU;wBAChC,MAAM,cAAc,CAAA,GAAA,0MAAA,CAAA,iBAAc,AAAD,EAAE,SAAS;wBAC5C,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,kBAAkB,EAAE,QAAQ,iBAAiB,EAAE,cAAc,EAAE,CAAC,GAC/D,CAAA,GAAA,sMAAA,CAAA,aAAU,AAAD,EAAE,cACb;4BACE,OAAO;wBACT;oBAGN;gBACF;YACF;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 247, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../../language/ast.mjs';\nimport { DirectiveLocation } from '../../language/directiveLocation.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\nexport function KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name) => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(\n          new GraphQLError(`Unknown directive \"@${name}\".`, {\n            nodes: node,\n          }),\n        );\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${name}\" may not be used on ${candidateLocation}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || invariant(false);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      'kind' in parentNode || invariant(false);\n      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n        ? DirectiveLocation.INPUT_FIELD_DEFINITION\n        : DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(appliedTo.kind));\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case OperationTypeNode.QUERY:\n      return DirectiveLocation.QUERY;\n\n    case OperationTypeNode.MUTATION:\n      return DirectiveLocation.MUTATION;\n\n    case OperationTypeNode.SUBSCRIPTION:\n      return DirectiveLocation.SUBSCRIPTION;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spread-target-defined\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread(node) {\n      const fragmentName = node.name.value;\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(\n          new GraphQLError(`Unknown fragment \"${fragmentName}\".`, {\n            nodes: node.name,\n          }),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,uBAAuB,OAAO;IAC5C,OAAO;QACL,gBAAe,IAAI;YACjB,MAAM,eAAe,KAAK,IAAI,CAAC,KAAK;YACpC,MAAM,WAAW,QAAQ,WAAW,CAAC;YAErC,IAAI,CAAC,UAAU;gBACb,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CAAC,CAAC,kBAAkB,EAAE,aAAa,EAAE,CAAC,EAAE;oBACtD,OAAO,KAAK,IAAI;gBAClB;YAEJ;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 388, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeSystemDefinitionNode,\n  isTypeSystemExtensionNode,\n} from '../../language/predicates.mjs';\nimport { introspectionTypes } from '../../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../../type/scalars.mjs';\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nexport function KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = suggestionList(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new GraphQLError(\n            `Unknown type \"${typeName}\".` + didYouMean(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\nconst standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(\n  (type) => type.name,\n);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value))\n  );\n}\n"],"names":[],"mappings":";;;AAGA;AAFA;AACA;AAFA;AASA;AADA;;;;;;;AAWO,SAAS,mBAAmB,OAAO;IACxC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,mBAAmB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACtE,MAAM,eAAe,OAAO,MAAM,CAAC;IAEnC,KAAK,MAAM,OAAO,QAAQ,WAAW,GAAG,WAAW,CAAE;QACnD,IAAI,CAAA,GAAA,uMAAA,CAAA,uBAAoB,AAAD,EAAE,MAAM;YAC7B,YAAY,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG;QACjC;IACF;IAEA,MAAM,YAAY;WACb,OAAO,IAAI,CAAC;WACZ,OAAO,IAAI,CAAC;KAChB;IACD,OAAO;QACL,WAAU,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,SAAS;YACvC,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;YAEhC,IAAI,CAAC,gBAAgB,CAAC,SAAS,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;gBAC1D,IAAI;gBAEJ,MAAM,iBACJ,CAAC,cAAc,SAAS,CAAC,EAAE,MAAM,QAAQ,gBAAgB,KAAK,IAC1D,cACA;gBACN,MAAM,QAAQ,kBAAkB,QAAQ,UAAU;gBAElD,IAAI,SAAS,kBAAkB,QAAQ,CAAC,WAAW;oBACjD;gBACF;gBAEA,MAAM,iBAAiB,CAAA,GAAA,0MAAA,CAAA,iBAAc,AAAD,EAClC,UACA,QAAQ,kBAAkB,MAAM,CAAC,aAAa;gBAEhD,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,cAAc,EAAE,SAAS,EAAE,CAAC,GAAG,CAAA,GAAA,sMAAA,CAAA,aAAU,AAAD,EAAE,iBAC3C;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF;AACA,MAAM,oBAAoB;OAAI,gMAAA,CAAA,uBAAoB;OAAK,sMAAA,CAAA,qBAAkB;CAAC,CAAC,GAAG,CAC5E,CAAC,OAAS,KAAK,IAAI;AAGrB,SAAS,UAAU,KAAK;IACtB,OACE,UAAU,SACV,CAAC,CAAA,GAAA,uMAAA,CAAA,6BAA0B,AAAD,EAAE,UAAU,CAAA,GAAA,uMAAA,CAAA,4BAAyB,AAAD,EAAE,MAAM;AAE1E","ignoreList":[0]}},
    {"offset": {"line": 441, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 447, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n *\n * See https://spec.graphql.org/draft/#sec-Lone-Anonymous-Operation\n */\nexport function LoneAnonymousOperationRule(context) {\n  let operationCount = 0;\n  return {\n    Document(node) {\n      operationCount = node.definitions.filter(\n        (definition) => definition.kind === Kind.OPERATION_DEFINITION,\n      ).length;\n    },\n\n    OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(\n          new GraphQLError(\n            'This anonymous operation must be the only defined operation.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AACA;AADA;;;AAWO,SAAS,2BAA2B,OAAO;IAChD,IAAI,iBAAiB;IACrB,OAAO;QACL,UAAS,IAAI;YACX,iBAAiB,KAAK,WAAW,CAAC,MAAM,CACtC,CAAC,aAAe,WAAW,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,oBAAoB,EAC7D,MAAM;QACV;QAEA,qBAAoB,IAAI;YACtB,IAAI,CAAC,KAAK,IAAI,IAAI,iBAAiB,GAAG;gBACpC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,gEACA;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 475, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  const oldSchema = context.getSchema();\n  const alreadyDefined =\n    (_ref =\n      (_ref2 =\n        (_oldSchema$astNode =\n          oldSchema === null || oldSchema === void 0\n            ? void 0\n            : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0\n          ? _oldSchema$astNode\n          : oldSchema === null || oldSchema === void 0\n          ? void 0\n          : oldSchema.getQueryType()) !== null && _ref2 !== void 0\n        ? _ref2\n        : oldSchema === null || oldSchema === void 0\n        ? void 0\n        : oldSchema.getMutationType()) !== null && _ref !== void 0\n      ? _ref\n      : oldSchema === null || oldSchema === void 0\n      ? void 0\n      : oldSchema.getSubscriptionType();\n  let schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(\n          new GraphQLError(\n            'Cannot define a new schema within a schema extension.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(\n          new GraphQLError('Must provide only one schema definition.', {\n            nodes: node,\n          }),\n        );\n      }\n\n      ++schemaDefinitionsCount;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,MAAM,OAAO;IAEjB,MAAM,YAAY,QAAQ,SAAS;IACnC,MAAM,iBACJ,CAAC,OACC,CAAC,QACC,CAAC,qBACC,cAAc,QAAQ,cAAc,KAAK,IACrC,KAAK,IACL,UAAU,OAAO,MAAM,QAAQ,uBAAuB,KAAK,IAC7D,qBACA,cAAc,QAAQ,cAAc,KAAK,IACzC,KAAK,IACL,UAAU,YAAY,EAAE,MAAM,QAAQ,UAAU,KAAK,IACvD,QACA,cAAc,QAAQ,cAAc,KAAK,IACzC,KAAK,IACL,UAAU,eAAe,EAAE,MAAM,QAAQ,SAAS,KAAK,IACzD,OACA,cAAc,QAAQ,cAAc,KAAK,IACzC,KAAK,IACL,UAAU,mBAAmB;IACnC,IAAI,yBAAyB;IAC7B,OAAO;QACL,kBAAiB,IAAI;YACnB,IAAI,gBAAgB;gBAClB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,yDACA;oBACE,OAAO;gBACT;gBAGJ;YACF;YAEA,IAAI,yBAAyB,GAAG;gBAC9B,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CAAC,4CAA4C;oBAC3D,OAAO;gBACT;YAEJ;YAEA,EAAE;QACJ;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 508, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs"],"sourcesContent":["import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAYO,SAAS,uBAAuB,OAAO;IAC5C,OAAO;QACL,OAAM,IAAI;YACR,MAAM,WAAW,QAAQ,WAAW;YACpC,MAAM,oBACJ,aAAa,QAAQ,aAAa,KAAK,IACnC,KAAK,IACL,SAAS,iBAAiB;YAEhC,IAAI,YAAY,qBAAqB,MAAM;gBACzC,MAAM,aAAa,QAAQ,aAAa;gBACxC,cAAc,QAAQ,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;gBAChC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,UAAU,EAAE,WAAW,IAAI,CAAC,CAAC,EAAE,SAAS,IAAI,CAAC,gBAAgB,EAAE,mBAAmB,EACnF;oBACE,OAAO;gBACT;YAGN;QACF;QAEA,UAAS,IAAI;YACX,MAAM,SAAS,QAAQ,WAAW;YAClC,MAAM,oBACJ,WAAW,QAAQ,WAAW,KAAK,IAC/B,KAAK,IACL,OAAO,iBAAiB;YAE9B,IAAI,UAAU,qBAAqB,MAAM;gBACvC,MAAM,eAAe,QAAQ,YAAY;gBAEzC,IAAI,gBAAgB,MAAM;oBACxB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,YAAY,EAAE,aAAa,IAAI,CAAC,YAAY,EAAE,OAAO,IAAI,CAAC,iBAAiB,EAAE,mBAAmB,EACjG;wBACE,OAAO;oBACT;gBAGN,OAAO;oBACL,MAAM,aAAa,QAAQ,aAAa;oBACxC,MAAM,WAAW,QAAQ,WAAW;oBACnC,cAAc,QAAQ,YAAY,QAAS,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;oBACtD,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,WAAW,IAAI,CAAC,CAAC,EAAE,SAAS,IAAI,CAAC,YAAY,EAAE,OAAO,IAAI,CAAC,iBAAiB,EAAE,mBAAmB,EAC3G;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;QAEA,aAAY,IAAI;YACd,MAAM,iBAAiB,CAAA,GAAA,mMAAA,CAAA,eAAY,AAAD,EAAE,QAAQ,kBAAkB;YAE9D,IAAI,CAAA,GAAA,mMAAA,CAAA,oBAAiB,AAAD,EAAE,iBAAiB;gBACrC,MAAM,gBAAgB,eAAe,SAAS,EAAE,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC;gBACjE,MAAM,oBACJ,kBAAkB,QAAQ,kBAAkB,KAAK,IAC7C,KAAK,IACL,cAAc,iBAAiB;gBAErC,IAAI,qBAAqB,MAAM;oBAC7B,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,gBAAgB,EAAE,eAAe,IAAI,CAAC,CAAC,EAAE,cAAc,IAAI,CAAC,gBAAgB,EAAE,mBAAmB,EAClG;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;QAEA,WAAU,IAAI;YACZ,MAAM,eAAe,QAAQ,YAAY;YACzC,MAAM,oBACJ,iBAAiB,QAAQ,iBAAiB,KAAK,IAC3C,KAAK,IACL,aAAa,iBAAiB;YAEpC,IAAI,gBAAgB,qBAAqB,MAAM;gBAC7C,MAAM,cAAc,CAAA,GAAA,mMAAA,CAAA,eAAY,AAAD,EAAE,QAAQ,YAAY;gBACrD,eAAe,QAAQ,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;gBACjC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,gBAAgB,EAAE,YAAY,IAAI,CAAC,CAAC,EAAE,aAAa,IAAI,CAAC,iBAAiB,EAAE,mBAAmB,EAC/F;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 580, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,qBAAqB,OAAO;IAC1C,8EAA8E;IAC9E,gCAAgC;IAChC,MAAM,eAAe,OAAO,MAAM,CAAC,OAAO,uDAAuD;IAEjG,MAAM,aAAa,EAAE,EAAE,8BAA8B;IAErD,MAAM,wBAAwB,OAAO,MAAM,CAAC;IAC5C,OAAO;QACL,qBAAqB,IAAM;QAE3B,oBAAmB,IAAI;YACrB,qBAAqB;YACrB,OAAO;QACT;IACF,GAAG,mDAAmD;;IACtD,wEAAwE;IACxE,yCAAyC;IAEzC,SAAS,qBAAqB,QAAQ;QACpC,IAAI,YAAY,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,EAAE;YACrC;QACF;QAEA,MAAM,eAAe,SAAS,IAAI,CAAC,KAAK;QACxC,YAAY,CAAC,aAAa,GAAG;QAC7B,MAAM,cAAc,QAAQ,kBAAkB,CAAC,SAAS,YAAY;QAEpE,IAAI,YAAY,MAAM,KAAK,GAAG;YAC5B;QACF;QAEA,qBAAqB,CAAC,aAAa,GAAG,WAAW,MAAM;QAEvD,KAAK,MAAM,cAAc,YAAa;YACpC,MAAM,aAAa,WAAW,IAAI,CAAC,KAAK;YACxC,MAAM,aAAa,qBAAqB,CAAC,WAAW;YACpD,WAAW,IAAI,CAAC;YAEhB,IAAI,eAAe,WAAW;gBAC5B,MAAM,iBAAiB,QAAQ,WAAW,CAAC;gBAE3C,IAAI,gBAAgB;oBAClB,qBAAqB;gBACvB;YACF,OAAO;gBACL,MAAM,YAAY,WAAW,KAAK,CAAC;gBACnC,MAAM,UAAU,UACb,KAAK,CAAC,GAAG,CAAC,GACV,GAAG,CAAC,CAAC,IAAM,MAAM,EAAE,IAAI,CAAC,KAAK,GAAG,KAChC,IAAI,CAAC;gBACR,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,wBAAwB,EAAE,WAAW,eAAe,CAAC,GACpD,CAAC,YAAY,KAAK,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,GAAG,GAAG,GAC5C;oBACE,OAAO;gBACT;YAGN;YAEA,WAAW,GAAG;QAChB;QAEA,qBAAqB,CAAC,aAAa,GAAG;IACxC;AACF","ignoreList":[0]}},
    {"offset": {"line": 633, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 639, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType } from '../../../type/definition.mjs';\nimport { isIntrospectionType } from '../../../type/introspection.mjs';\n\n/**\n * Prohibit introspection queries\n *\n * A GraphQL document is only valid if all fields selected are not fields that\n * return an introspection type.\n *\n * Note: This rule is optional and is not part of the Validation section of the\n * GraphQL Specification. This rule effectively disables introspection, which\n * does not reflect best practices and should only be done if absolutely necessary.\n */\nexport function NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field(node) {\n      const type = getNamedType(context.getType());\n\n      if (type && isIntrospectionType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `GraphQL introspection has been disabled, but the requested query contained the field \"${node.name.value}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AACA;AACA;AAFA;;;;AAcO,SAAS,gCAAgC,OAAO;IACrD,OAAO;QACL,OAAM,IAAI;YACR,MAAM,OAAO,CAAA,GAAA,mMAAA,CAAA,eAAY,AAAD,EAAE,QAAQ,OAAO;YAEzC,IAAI,QAAQ,CAAA,GAAA,sMAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;gBACrC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,sFAAsF,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAC5G;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 660, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 666, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Uses-Defined\n */\nexport function NoUndefinedVariablesRule(context) {\n  let variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        variableNameDefined = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          const varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${varName}\" is not defined by operation \"${operation.name.value}\".`\n                  : `Variable \"$${varName}\" is not defined.`,\n                {\n                  nodes: [node, operation],\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,sBAAsB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,qBAAqB;YACnB;gBACE,sBAAsB,OAAO,MAAM,CAAC;YACtC;YAEA,OAAM,SAAS;gBACb,MAAM,SAAS,QAAQ,0BAA0B,CAAC;gBAElD,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,OAAQ;oBAC7B,MAAM,UAAU,KAAK,IAAI,CAAC,KAAK;oBAE/B,IAAI,mBAAmB,CAAC,QAAQ,KAAK,MAAM;wBACzC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,UAAU,IAAI,GACV,CAAC,WAAW,EAAE,QAAQ,+BAA+B,EAAE,UAAU,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAC/E,CAAC,WAAW,EAAE,QAAQ,iBAAiB,CAAC,EAC5C;4BACE,OAAO;gCAAC;gCAAM;6BAAU;wBAC1B;oBAGN;gBACF;YACF;QACF;QAEA,oBAAmB,IAAI;YACrB,mBAAmB,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QAClD;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 704, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-Must-Be-Used\n */\nexport function NoUnusedFragmentsRule(context) {\n  const operationDefs = [];\n  const fragmentDefs = [];\n  return {\n    OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n\n    FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n\n    Document: {\n      leave() {\n        const fragmentNameUsed = Object.create(null);\n\n        for (const operation of operationDefs) {\n          for (const fragment of context.getRecursivelyReferencedFragments(\n            operation,\n          )) {\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (const fragmentDef of fragmentDefs) {\n          const fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(\n              new GraphQLError(`Fragment \"${fragName}\" is never used.`, {\n                nodes: fragmentDef,\n              }),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,sBAAsB,OAAO;IAC3C,MAAM,gBAAgB,EAAE;IACxB,MAAM,eAAe,EAAE;IACvB,OAAO;QACL,qBAAoB,IAAI;YACtB,cAAc,IAAI,CAAC;YACnB,OAAO;QACT;QAEA,oBAAmB,IAAI;YACrB,aAAa,IAAI,CAAC;YAClB,OAAO;QACT;QAEA,UAAU;YACR;gBACE,MAAM,mBAAmB,OAAO,MAAM,CAAC;gBAEvC,KAAK,MAAM,aAAa,cAAe;oBACrC,KAAK,MAAM,YAAY,QAAQ,iCAAiC,CAC9D,WACC;wBACD,gBAAgB,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,GAAG;oBAC1C;gBACF;gBAEA,KAAK,MAAM,eAAe,aAAc;oBACtC,MAAM,WAAW,YAAY,IAAI,CAAC,KAAK;oBAEvC,IAAI,gBAAgB,CAAC,SAAS,KAAK,MAAM;wBACvC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CAAC,CAAC,UAAU,EAAE,SAAS,gBAAgB,CAAC,EAAE;4BACxD,OAAO;wBACT;oBAEJ;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 741, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 747, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variables-Used\n */\nexport function NoUnusedVariablesRule(context) {\n  let variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefs = [];\n      },\n\n      leave(operation) {\n        const variableNameUsed = Object.create(null);\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (const variableDef of variableDefs) {\n          const variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${variableName}\" is never used in operation \"${operation.name.value}\".`\n                  : `Variable \"$${variableName}\" is never used.`,\n                {\n                  nodes: variableDef,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(def) {\n      variableDefs.push(def);\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,sBAAsB,OAAO;IAC3C,IAAI,eAAe,EAAE;IACrB,OAAO;QACL,qBAAqB;YACnB;gBACE,eAAe,EAAE;YACnB;YAEA,OAAM,SAAS;gBACb,MAAM,mBAAmB,OAAO,MAAM,CAAC;gBACvC,MAAM,SAAS,QAAQ,0BAA0B,CAAC;gBAElD,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,OAAQ;oBAC7B,gBAAgB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG;gBACtC;gBAEA,KAAK,MAAM,eAAe,aAAc;oBACtC,MAAM,eAAe,YAAY,QAAQ,CAAC,IAAI,CAAC,KAAK;oBAEpD,IAAI,gBAAgB,CAAC,aAAa,KAAK,MAAM;wBAC3C,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,UAAU,IAAI,GACV,CAAC,WAAW,EAAE,aAAa,8BAA8B,EAAE,UAAU,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GACnF,CAAC,WAAW,EAAE,aAAa,gBAAgB,CAAC,EAChD;4BACE,OAAO;wBACT;oBAGN;gBACF;YACF;QACF;QAEA,oBAAmB,GAAG;YACpB,aAAa,IAAI,CAAC;QACpB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 780, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 786, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (\n      comparedFragmentPairs.has(\n        referencedFragmentName,\n        fragmentName,\n        areMutuallyExclusive,\n      )\n    ) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(\n      referencedFragmentName,\n      fragmentName,\n      areMutuallyExclusive,\n    );\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (!sameArguments(node1, node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(node1, node2) {\n  const args1 = node1.arguments;\n  const args2 = node2.arguments;\n\n  if (args1 === undefined || args1.length === 0) {\n    return args2 === undefined || args2.length === 0;\n  }\n\n  if (args2 === undefined || args2.length === 0) {\n    return false;\n  }\n  /* c8 ignore next */\n\n  if (args1.length !== args2.length) {\n    /* c8 ignore next */\n    return false;\n    /* c8 ignore next */\n  }\n\n  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));\n  return args1.every((arg1) => {\n    const value1 = arg1.value;\n    const value2 = values2.get(arg1.name.value);\n\n    if (value2 === undefined) {\n      return false;\n    }\n\n    return stringifyValue(value1) === stringifyValue(value2);\n  });\n}\n\nfunction stringifyValue(value) {\n  return print(sortValueNode(value));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1266, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1272, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { doTypesOverlap } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        isCompositeType(fragType) &&\n        isCompositeType(parentType) &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAEA;AACA;AAHA;AACA;AAGA;;;;;;AASO,SAAS,4BAA4B,OAAO;IACjD,OAAO;QACL,gBAAe,IAAI;YACjB,MAAM,WAAW,QAAQ,OAAO;YAChC,MAAM,aAAa,QAAQ,aAAa;YAExC,IACE,CAAA,GAAA,mMAAA,CAAA,kBAAe,AAAD,EAAE,aAChB,CAAA,GAAA,mMAAA,CAAA,kBAAe,AAAD,EAAE,eAChB,CAAC,CAAA,GAAA,6MAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ,SAAS,IAAI,UAAU,aAC/C;gBACA,MAAM,gBAAgB,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE;gBAC9B,MAAM,cAAc,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE;gBAC5B,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,mDAAmD,EAAE,cAAc,wBAAwB,EAAE,YAAY,EAAE,CAAC,EAC7G;oBACE,OAAO;gBACT;YAGN;QACF;QAEA,gBAAe,IAAI;YACjB,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;YAChC,MAAM,WAAW,gBAAgB,SAAS;YAC1C,MAAM,aAAa,QAAQ,aAAa;YAExC,IACE,YACA,cACA,CAAC,CAAA,GAAA,6MAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ,SAAS,IAAI,UAAU,aAC/C;gBACA,MAAM,gBAAgB,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE;gBAC9B,MAAM,cAAc,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE;gBAC5B,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,UAAU,EAAE,SAAS,4CAA4C,EAAE,cAAc,wBAAwB,EAAE,YAAY,EAAE,CAAC,EAC3H;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF;AAEA,SAAS,gBAAgB,OAAO,EAAE,IAAI;IACpC,MAAM,OAAO,QAAQ,WAAW,CAAC;IAEjC,IAAI,MAAM;QACR,MAAM,OAAO,CAAA,GAAA,yMAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI,KAAK,aAAa;QAEhE,IAAI,CAAA,GAAA,mMAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;YACzB,OAAO;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1321, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1327, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1444, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1450, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isRequiredArgument, isType } from '../../type/definition.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...ProvidedRequiredArgumentsOnDirectivesRule(context),\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        }\n\n        const providedArgs = new Set( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n          /* c8 ignore next */\n          (_fieldNode$arguments = fieldNode.arguments) === null ||\n          _fieldNode$arguments === void 0\n            ? void 0\n            : _fieldNode$arguments.map((arg) => arg.name.value),\n        );\n\n        for (const argDef of fieldDef.args) {\n          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {\n            const argTypeStr = inspect(argDef.type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldDef.name}\" argument \"${argDef.name}\" of type \"${argTypeStr}\" is required, but it was not provided.`,\n                {\n                  nodes: fieldNode,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var _schema$getDirectives;\n\n  const requiredArgsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives =\n    (_schema$getDirectives =\n      schema === null || schema === void 0\n        ? void 0\n        : schema.getDirectives()) !== null && _schema$getDirectives !== void 0\n      ? _schema$getDirectives\n      : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    requiredArgsMap[directive.name] = keyMap(\n      directive.args.filter(isRequiredArgument),\n      (arg) => arg.name,\n    );\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      requiredArgsMap[def.name.value] = keyMap(\n        argNodes.filter(isRequiredArgumentNode),\n        (arg) => arg.name.value,\n      );\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(directiveNode) {\n        const directiveName = directiveNode.name.value;\n        const requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n          /* c8 ignore next */\n          const argNodes =\n            (_directiveNode$argume = directiveNode.arguments) !== null &&\n            _directiveNode$argume !== void 0\n              ? _directiveNode$argume\n              : [];\n          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));\n\n          for (const [argName, argDef] of Object.entries(requiredArgs)) {\n            if (!argNodeMap.has(argName)) {\n              const argType = isType(argDef.type)\n                ? inspect(argDef.type)\n                : print(argDef.type);\n              context.reportError(\n                new GraphQLError(\n                  `Directive \"@${directiveName}\" argument \"${argName}\" of type \"${argType}\" is required, but it was not provided.`,\n                  {\n                    nodes: directiveNode,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n"],"names":[],"mappings":";;;;AAKA;AALA;AAEA;AAIA;AALA;AAEA;AACA;;;;;;;;AAUO,SAAS,8BAA8B,OAAO;IACnD,OAAO;QACL,mCAAmC;QACnC,GAAG,0CAA0C,QAAQ;QACrD,OAAO;YACL,gEAAgE;YAChE,OAAM,SAAS;gBACb,IAAI;gBAEJ,MAAM,WAAW,QAAQ,WAAW;gBAEpC,IAAI,CAAC,UAAU;oBACb,OAAO;gBACT;gBAEA,MAAM,eAAe,IAAI,IACvB,kBAAkB,GAClB,CAAC,uBAAuB,UAAU,SAAS,MAAM,QACjD,yBAAyB,KAAK,IAC1B,KAAK,IACL,qBAAqB,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;gBAGtD,KAAK,MAAM,UAAU,SAAS,IAAI,CAAE;oBAClC,IAAI,CAAC,aAAa,GAAG,CAAC,OAAO,IAAI,KAAK,CAAA,GAAA,mMAAA,CAAA,qBAAkB,AAAD,EAAE,SAAS;wBAChE,MAAM,aAAa,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE,OAAO,IAAI;wBACtC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,SAAS,IAAI,CAAC,YAAY,EAAE,OAAO,IAAI,CAAC,WAAW,EAAE,WAAW,uCAAuC,CAAC,EAClH;4BACE,OAAO;wBACT;oBAGN;gBACF;YACF;QACF;IACF;AACF;AAKO,SAAS,0CAA0C,OAAO;IAC/D,IAAI;IAEJ,MAAM,kBAAkB,OAAO,MAAM,CAAC;IACtC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,oBACJ,CAAC,wBACC,WAAW,QAAQ,WAAW,KAAK,IAC/B,KAAK,IACL,OAAO,aAAa,EAAE,MAAM,QAAQ,0BAA0B,KAAK,IACrE,wBACA,mMAAA,CAAA,sBAAmB;IAEzB,KAAK,MAAM,aAAa,kBAAmB;QACzC,eAAe,CAAC,UAAU,IAAI,CAAC,GAAG,CAAA,GAAA,kMAAA,CAAA,SAAM,AAAD,EACrC,UAAU,IAAI,CAAC,MAAM,CAAC,mMAAA,CAAA,qBAAkB,GACxC,CAAC,MAAQ,IAAI,IAAI;IAErB;IAEA,MAAM,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAExD,KAAK,MAAM,OAAO,eAAgB;QAChC,IAAI,IAAI,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,oBAAoB,EAAE;YAC1C,IAAI;YAEJ,2DAA2D;YAE3D,kBAAkB,GAClB,MAAM,WACJ,CAAC,iBAAiB,IAAI,SAAS,MAAM,QAAQ,mBAAmB,KAAK,IACjE,iBACA,EAAE;YACR,eAAe,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAA,GAAA,kMAAA,CAAA,SAAM,AAAD,EACrC,SAAS,MAAM,CAAC,yBAChB,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QAE3B;IACF;IAEA,OAAO;QACL,WAAW;YACT,gEAAgE;YAChE,OAAM,aAAa;gBACjB,MAAM,gBAAgB,cAAc,IAAI,CAAC,KAAK;gBAC9C,MAAM,eAAe,eAAe,CAAC,cAAc;gBAEnD,IAAI,cAAc;oBAChB,IAAI;oBAEJ,2DAA2D;oBAE3D,kBAAkB,GAClB,MAAM,WACJ,CAAC,wBAAwB,cAAc,SAAS,MAAM,QACtD,0BAA0B,KAAK,IAC3B,wBACA,EAAE;oBACR,MAAM,aAAa,IAAI,IAAI,SAAS,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;oBAE/D,KAAK,MAAM,CAAC,SAAS,OAAO,IAAI,OAAO,OAAO,CAAC,cAAe;wBAC5D,IAAI,CAAC,WAAW,GAAG,CAAC,UAAU;4BAC5B,MAAM,UAAU,CAAA,GAAA,mMAAA,CAAA,SAAM,AAAD,EAAE,OAAO,IAAI,IAC9B,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE,OAAO,IAAI,IACnB,CAAA,GAAA,oMAAA,CAAA,QAAK,AAAD,EAAE,OAAO,IAAI;4BACrB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,YAAY,EAAE,cAAc,YAAY,EAAE,QAAQ,WAAW,EAAE,QAAQ,uCAAuC,CAAC,EAChH;gCACE,OAAO;4BACT;wBAGN;oBACF;gBACF;YACF;QACF;IACF;AACF;AAEA,SAAS,uBAAuB,GAAG;IACjC,OAAO,IAAI,IAAI,CAAC,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,aAAa,IAAI,IAAI,YAAY,IAAI;AACrE","ignoreList":[0]}},
    {"offset": {"line": 1537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1543, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { getNamedType, isLeafType } from '../../type/definition.mjs';\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field(node) {\n      const type = context.getType();\n      const selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            const fieldName = node.name.value;\n            const typeStr = inspect(type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldName}\" must not have a selection since type \"${typeStr}\" has no subfields.`,\n                {\n                  nodes: selectionSet,\n                },\n              ),\n            );\n          }\n        } else if (!selectionSet) {\n          const fieldName = node.name.value;\n          const typeStr = inspect(type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have a selection of subfields. Did you mean \"${fieldName} { ... }\"?`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAEA;AAFA;AACA;;;;AASO,SAAS,gBAAgB,OAAO;IACrC,OAAO;QACL,OAAM,IAAI;YACR,MAAM,OAAO,QAAQ,OAAO;YAC5B,MAAM,eAAe,KAAK,YAAY;YAEtC,IAAI,MAAM;gBACR,IAAI,CAAA,GAAA,mMAAA,CAAA,aAAU,AAAD,EAAE,CAAA,GAAA,mMAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;oBAClC,IAAI,cAAc;wBAChB,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;wBACjC,MAAM,UAAU,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE;wBACxB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,UAAU,wCAAwC,EAAE,QAAQ,mBAAmB,CAAC,EAC1F;4BACE,OAAO;wBACT;oBAGN;gBACF,OAAO,IAAI,CAAC,cAAc;oBACxB,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;oBACjC,MAAM,UAAU,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE;oBACxB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,UAAU,WAAW,EAAE,QAAQ,oDAAoD,EAAE,UAAU,UAAU,CAAC,EACpH;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1577, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1583, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { collectFields } from '../../execution/collectFields.mjs';\n\n/**\n * Subscriptions must only include a non-introspection field.\n *\n * A GraphQL subscription is valid only if it contains a single root field and\n * that root field is not an introspection field.\n *\n * See https://spec.graphql.org/draft/#sec-Single-root-field\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        const schema = context.getSchema();\n        const subscriptionType = schema.getSubscriptionType();\n\n        if (subscriptionType) {\n          const operationName = node.name ? node.name.value : null;\n          const variableValues = Object.create(null);\n          const document = context.getDocument();\n          const fragments = Object.create(null);\n\n          for (const definition of document.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[definition.name.value] = definition;\n            }\n          }\n\n          const fields = collectFields(\n            schema,\n            fragments,\n            variableValues,\n            subscriptionType,\n            node.selectionSet,\n          );\n\n          if (fields.size > 1) {\n            const fieldSelectionLists = [...fields.values()];\n            const extraFieldSelectionLists = fieldSelectionLists.slice(1);\n            const extraFieldSelections = extraFieldSelectionLists.flat();\n            context.reportError(\n              new GraphQLError(\n                operationName != null\n                  ? `Subscription \"${operationName}\" must select only one top level field.`\n                  : 'Anonymous Subscription must select only one top level field.',\n                {\n                  nodes: extraFieldSelections,\n                },\n              ),\n            );\n          }\n\n          for (const fieldNodes of fields.values()) {\n            const field = fieldNodes[0];\n            const fieldName = field.name.value;\n\n            if (fieldName.startsWith('__')) {\n              context.reportError(\n                new GraphQLError(\n                  operationName != null\n                    ? `Subscription \"${operationName}\" must not select an introspection top level field.`\n                    : 'Anonymous Subscription must not select an introspection top level field.',\n                  {\n                    nodes: fieldNodes,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AACA;AACA;AAFA;;;;AAYO,SAAS,6BAA6B,OAAO;IAClD,OAAO;QACL,qBAAoB,IAAI;YACtB,IAAI,KAAK,SAAS,KAAK,gBAAgB;gBACrC,MAAM,SAAS,QAAQ,SAAS;gBAChC,MAAM,mBAAmB,OAAO,mBAAmB;gBAEnD,IAAI,kBAAkB;oBACpB,MAAM,gBAAgB,KAAK,IAAI,GAAG,KAAK,IAAI,CAAC,KAAK,GAAG;oBACpD,MAAM,iBAAiB,OAAO,MAAM,CAAC;oBACrC,MAAM,WAAW,QAAQ,WAAW;oBACpC,MAAM,YAAY,OAAO,MAAM,CAAC;oBAEhC,KAAK,MAAM,cAAc,SAAS,WAAW,CAAE;wBAC7C,IAAI,WAAW,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,mBAAmB,EAAE;4BAChD,SAAS,CAAC,WAAW,IAAI,CAAC,KAAK,CAAC,GAAG;wBACrC;oBACF;oBAEA,MAAM,SAAS,CAAA,GAAA,2MAAA,CAAA,gBAAa,AAAD,EACzB,QACA,WACA,gBACA,kBACA,KAAK,YAAY;oBAGnB,IAAI,OAAO,IAAI,GAAG,GAAG;wBACnB,MAAM,sBAAsB;+BAAI,OAAO,MAAM;yBAAG;wBAChD,MAAM,2BAA2B,oBAAoB,KAAK,CAAC;wBAC3D,MAAM,uBAAuB,yBAAyB,IAAI;wBAC1D,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,iBAAiB,OACb,CAAC,cAAc,EAAE,cAAc,uCAAuC,CAAC,GACvE,gEACJ;4BACE,OAAO;wBACT;oBAGN;oBAEA,KAAK,MAAM,cAAc,OAAO,MAAM,GAAI;wBACxC,MAAM,QAAQ,UAAU,CAAC,EAAE;wBAC3B,MAAM,YAAY,MAAM,IAAI,CAAC,KAAK;wBAElC,IAAI,UAAU,UAAU,CAAC,OAAO;4BAC9B,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,iBAAiB,OACb,CAAC,cAAc,EAAE,cAAc,mDAAmD,CAAC,GACnF,4EACJ;gCACE,OAAO;4BACT;wBAGN;oBACF;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1633, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1639, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs"],"sourcesContent":["import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument definition names\n *\n * A GraphQL Object or Interface type is only valid if all its fields have uniquely named arguments.\n * A GraphQL Directive is only valid if all its arguments are uniquely named.\n */\nexport function UniqueArgumentDefinitionNamesRule(context) {\n  return {\n    DirectiveDefinition(directiveNode) {\n      var _directiveNode$argume;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argumentNodes =\n        (_directiveNode$argume = directiveNode.arguments) !== null &&\n        _directiveNode$argume !== void 0\n          ? _directiveNode$argume\n          : [];\n      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);\n    },\n\n    InterfaceTypeDefinition: checkArgUniquenessPerField,\n    InterfaceTypeExtension: checkArgUniquenessPerField,\n    ObjectTypeDefinition: checkArgUniquenessPerField,\n    ObjectTypeExtension: checkArgUniquenessPerField,\n  };\n\n  function checkArgUniquenessPerField(typeNode) {\n    var _typeNode$fields;\n\n    const typeName = typeNode.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_typeNode$fields = typeNode.fields) !== null &&\n      _typeNode$fields !== void 0\n        ? _typeNode$fields\n        : [];\n\n    for (const fieldDef of fieldNodes) {\n      var _fieldDef$arguments;\n\n      const fieldName = fieldDef.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n\n      const argumentNodes =\n        (_fieldDef$arguments = fieldDef.arguments) !== null &&\n        _fieldDef$arguments !== void 0\n          ? _fieldDef$arguments\n          : [];\n      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);\n    }\n\n    return false;\n  }\n\n  function checkArgUniqueness(parentName, argumentNodes) {\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `Argument \"${parentName}(${argName}:)\" can only be defined once.`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAQO,SAAS,kCAAkC,OAAO;IACvD,OAAO;QACL,qBAAoB,aAAa;YAC/B,IAAI;YAEJ,2DAA2D;YAE3D,kBAAkB,GAClB,MAAM,gBACJ,CAAC,wBAAwB,cAAc,SAAS,MAAM,QACtD,0BAA0B,KAAK,IAC3B,wBACA,EAAE;YACR,OAAO,mBAAmB,CAAC,CAAC,EAAE,cAAc,IAAI,CAAC,KAAK,EAAE,EAAE;QAC5D;QAEA,yBAAyB;QACzB,wBAAwB;QACxB,sBAAsB;QACtB,qBAAqB;IACvB;;IAEA,SAAS,2BAA2B,QAAQ;QAC1C,IAAI;QAEJ,MAAM,WAAW,SAAS,IAAI,CAAC,KAAK,EAAE,2DAA2D;QAEjG,kBAAkB,GAElB,MAAM,aACJ,CAAC,mBAAmB,SAAS,MAAM,MAAM,QACzC,qBAAqB,KAAK,IACtB,mBACA,EAAE;QAER,KAAK,MAAM,YAAY,WAAY;YACjC,IAAI;YAEJ,MAAM,YAAY,SAAS,IAAI,CAAC,KAAK,EAAE,2DAA2D;YAElG,kBAAkB,GAElB,MAAM,gBACJ,CAAC,sBAAsB,SAAS,SAAS,MAAM,QAC/C,wBAAwB,KAAK,IACzB,sBACA,EAAE;YACR,mBAAmB,GAAG,SAAS,CAAC,EAAE,WAAW,EAAE;QACjD;QAEA,OAAO;IACT;IAEA,SAAS,mBAAmB,UAAU,EAAE,aAAa;QACnD,MAAM,WAAW,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE,eAAe,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QAE/D,KAAK,MAAM,CAAC,SAAS,SAAS,IAAI,SAAU;YAC1C,IAAI,SAAS,MAAM,GAAG,GAAG;gBACvB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,UAAU,EAAE,WAAW,CAAC,EAAE,QAAQ,6BAA6B,CAAC,EACjE;oBACE,OAAO,SAAS,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;gBACzC;YAGN;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1684, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1690, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs"],"sourcesContent":["import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n */\nexport function UniqueArgumentNamesRule(context) {\n  return {\n    Field: checkArgUniqueness,\n    Directive: checkArgUniqueness,\n  };\n\n  function checkArgUniqueness(parentNode) {\n    var _parentNode$arguments;\n\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const argumentNodes =\n      (_parentNode$arguments = parentNode.arguments) !== null &&\n      _parentNode$arguments !== void 0\n        ? _parentNode$arguments\n        : [];\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one argument named \"${argName}\".`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAUO,SAAS,wBAAwB,OAAO;IAC7C,OAAO;QACL,OAAO;QACP,WAAW;IACb;;IAEA,SAAS,mBAAmB,UAAU;QACpC,IAAI;QAEJ,2DAA2D;QAE3D,kBAAkB,GAClB,MAAM,gBACJ,CAAC,wBAAwB,WAAW,SAAS,MAAM,QACnD,0BAA0B,KAAK,IAC3B,wBACA,EAAE;QACR,MAAM,WAAW,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE,eAAe,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QAE/D,KAAK,MAAM,CAAC,SAAS,SAAS,IAAI,SAAU;YAC1C,IAAI,SAAS,MAAM,GAAG,GAAG;gBACvB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,sCAAsC,EAAE,QAAQ,EAAE,CAAC,EACpD;oBACE,OAAO,SAAS,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;gBACzC;YAGN;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1717, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1723, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  const knownDirectiveNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    DirectiveDefinition(node) {\n      const directiveName = node.name.value;\n\n      if (\n        schema !== null &&\n        schema !== void 0 &&\n        schema.getDirective(directiveName)\n      ) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${directiveName}\" already exists in the schema. It cannot be redefined.`,\n            {\n              nodes: node.name,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one directive named \"@${directiveName}\".`,\n            {\n              nodes: [knownDirectiveNames[directiveName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,MAAM,sBAAsB,OAAO,MAAM,CAAC;IAC1C,MAAM,SAAS,QAAQ,SAAS;IAChC,OAAO;QACL,qBAAoB,IAAI;YACtB,MAAM,gBAAgB,KAAK,IAAI,CAAC,KAAK;YAErC,IACE,WAAW,QACX,WAAW,KAAK,KAChB,OAAO,YAAY,CAAC,gBACpB;gBACA,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,YAAY,EAAE,cAAc,uDAAuD,CAAC,EACrF;oBACE,OAAO,KAAK,IAAI;gBAClB;gBAGJ;YACF;YAEA,IAAI,mBAAmB,CAAC,cAAc,EAAE;gBACtC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,wCAAwC,EAAE,cAAc,EAAE,CAAC,EAC5D;oBACE,OAAO;wBAAC,mBAAmB,CAAC,cAAc;wBAAE,KAAK,IAAI;qBAAC;gBACxD;YAGN,OAAO;gBACL,mBAAmB,CAAC,cAAc,GAAG,KAAK,IAAI;YAChD;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1754, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1760, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../../language/predicates.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  const uniqueDirectiveMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  const schemaDirectives = Object.create(null);\n  const typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter(node) {\n      if (!('directives' in node) || !node.directives) {\n        return;\n      }\n\n      let seenDirectives;\n\n      if (\n        node.kind === Kind.SCHEMA_DEFINITION ||\n        node.kind === Kind.SCHEMA_EXTENSION\n      ) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        const typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (const directive of node.directives) {\n        const directiveName = directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(\n              new GraphQLError(\n                `The directive \"@${directiveName}\" can only be used once at this location.`,\n                {\n                  nodes: [seenDirectives[directiveName], directive],\n                },\n              ),\n            );\n          } else {\n            seenDirectives[directiveName] = directive;\n          }\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAMA;AALA;AACA;AAFA;;;;;AAgBO,SAAS,gCAAgC,OAAO;IACrD,MAAM,qBAAqB,OAAO,MAAM,CAAC;IACzC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,oBAAoB,SACtB,OAAO,aAAa,KACpB,mMAAA,CAAA,sBAAmB;IAEvB,KAAK,MAAM,aAAa,kBAAmB;QACzC,kBAAkB,CAAC,UAAU,IAAI,CAAC,GAAG,CAAC,UAAU,YAAY;IAC9D;IAEA,MAAM,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAExD,KAAK,MAAM,OAAO,eAAgB;QAChC,IAAI,IAAI,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,oBAAoB,EAAE;YAC1C,kBAAkB,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,UAAU;QACtD;IACF;IAEA,MAAM,mBAAmB,OAAO,MAAM,CAAC;IACvC,MAAM,oBAAoB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,uEAAuE;QACvE,sEAAsE;QACtE,0BAA0B;QAC1B,OAAM,IAAI;YACR,IAAI,CAAC,CAAC,gBAAgB,IAAI,KAAK,CAAC,KAAK,UAAU,EAAE;gBAC/C;YACF;YAEA,IAAI;YAEJ,IACE,KAAK,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,iBAAiB,IACpC,KAAK,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,gBAAgB,EACnC;gBACA,iBAAiB;YACnB,OAAO,IAAI,CAAA,GAAA,uMAAA,CAAA,uBAAoB,AAAD,EAAE,SAAS,CAAA,GAAA,uMAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;gBAClE,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;gBAChC,iBAAiB,iBAAiB,CAAC,SAAS;gBAE5C,IAAI,mBAAmB,WAAW;oBAChC,iBAAiB,CAAC,SAAS,GAAG,iBAAiB,OAAO,MAAM,CAAC;gBAC/D;YACF,OAAO;gBACL,iBAAiB,OAAO,MAAM,CAAC;YACjC;YAEA,KAAK,MAAM,aAAa,KAAK,UAAU,CAAE;gBACvC,MAAM,gBAAgB,UAAU,IAAI,CAAC,KAAK;gBAE1C,IAAI,kBAAkB,CAAC,cAAc,EAAE;oBACrC,IAAI,cAAc,CAAC,cAAc,EAAE;wBACjC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,gBAAgB,EAAE,cAAc,yCAAyC,CAAC,EAC3E;4BACE,OAAO;gCAAC,cAAc,CAAC,cAAc;gCAAE;6BAAU;wBACnD;oBAGN,OAAO;wBACL,cAAc,CAAC,cAAc,GAAG;oBAClC;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1824, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1830, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isEnumType } from '../../type/definition.mjs';\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness,\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    const typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const valueNodes =\n      (_node$values = node.values) !== null && _node$values !== void 0\n        ? _node$values\n        : [];\n    const valueNames = knownValueNames[typeName];\n\n    for (const valueDef of valueNodes) {\n      const valueName = valueDef.name.value;\n      const existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: valueDef.name,\n            },\n          ),\n        );\n      } else if (valueNames[valueName]) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" can only be defined once.`,\n            {\n              nodes: [valueNames[valueName], valueDef.name],\n            },\n          ),\n        );\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AACA;AADA;;;AAQO,SAAS,yBAAyB,OAAO;IAC9C,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACrE,MAAM,kBAAkB,OAAO,MAAM,CAAC;IACtC,OAAO;QACL,oBAAoB;QACpB,mBAAmB;IACrB;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAEhC,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,2DAA2D;QAE7D,kBAAkB,GAElB,MAAM,aACJ,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAC3D,eACA,EAAE;QACR,MAAM,aAAa,eAAe,CAAC,SAAS;QAE5C,KAAK,MAAM,YAAY,WAAY;YACjC,MAAM,YAAY,SAAS,IAAI,CAAC,KAAK;YACrC,MAAM,eAAe,eAAe,CAAC,SAAS;YAE9C,IAAI,CAAA,GAAA,mMAAA,CAAA,aAAU,AAAD,EAAE,iBAAiB,aAAa,QAAQ,CAAC,YAAY;gBAChE,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,YAAY,EAAE,SAAS,CAAC,EAAE,UAAU,iFAAiF,CAAC,EACvH;oBACE,OAAO,SAAS,IAAI;gBACtB;YAGN,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,YAAY,EAAE,SAAS,CAAC,EAAE,UAAU,2BAA2B,CAAC,EACjE;oBACE,OAAO;wBAAC,UAAU,CAAC,UAAU;wBAAE,SAAS,IAAI;qBAAC;gBAC/C;YAGN,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1875, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1881, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_node$fields = node.fields) !== null && _node$fields !== void 0\n        ? _node$fields\n        : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: fieldDef.name,\n            },\n          ),\n        );\n      } else if (fieldNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" can only be defined once.`,\n            {\n              nodes: [fieldNames[fieldName], fieldDef.name],\n            },\n          ),\n        );\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAWO,SAAS,+BAA+B,OAAO;IACpD,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACrE,MAAM,kBAAkB,OAAO,MAAM,CAAC;IACtC,OAAO;QACL,2BAA2B;QAC3B,0BAA0B;QAC1B,yBAAyB;QACzB,wBAAwB;QACxB,sBAAsB;QACtB,qBAAqB;IACvB;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAEhC,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,2DAA2D;QAE7D,kBAAkB,GAElB,MAAM,aACJ,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAC3D,eACA,EAAE;QACR,MAAM,aAAa,eAAe,CAAC,SAAS;QAE5C,KAAK,MAAM,YAAY,WAAY;YACjC,MAAM,YAAY,SAAS,IAAI,CAAC,KAAK;YAErC,IAAI,SAAS,eAAe,CAAC,SAAS,EAAE,YAAY;gBAClD,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,UAAU,iFAAiF,CAAC,EAClH;oBACE,OAAO,SAAS,IAAI;gBACtB;YAGN,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,UAAU,2BAA2B,CAAC,EAC5D;oBACE,OAAO;wBAAC,UAAU,CAAC,UAAU;wBAAE,SAAS,IAAI;qBAAC;gBAC/C;YAGN,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF;AAEA,SAAS,SAAS,IAAI,EAAE,SAAS;IAC/B,IAAI,CAAA,GAAA,mMAAA,CAAA,eAAY,AAAD,EAAE,SAAS,CAAA,GAAA,mMAAA,CAAA,kBAAe,AAAD,EAAE,SAAS,CAAA,GAAA,mMAAA,CAAA,oBAAiB,AAAD,EAAE,OAAO;QAC1E,OAAO,KAAK,SAAS,EAAE,CAAC,UAAU,IAAI;IACxC;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1935, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1941, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Name-Uniqueness\n */\nexport function UniqueFragmentNamesRule(context) {\n  const knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      const fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one fragment named \"${fragmentName}\".`,\n            {\n              nodes: [knownFragmentNames[fragmentName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AASO,SAAS,wBAAwB,OAAO;IAC7C,MAAM,qBAAqB,OAAO,MAAM,CAAC;IACzC,OAAO;QACL,qBAAqB,IAAM;QAE3B,oBAAmB,IAAI;YACrB,MAAM,eAAe,KAAK,IAAI,CAAC,KAAK;YAEpC,IAAI,kBAAkB,CAAC,aAAa,EAAE;gBACpC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,sCAAsC,EAAE,aAAa,EAAE,CAAC,EACzD;oBACE,OAAO;wBAAC,kBAAkB,CAAC,aAAa;wBAAE,KAAK,IAAI;qBAAC;gBACtD;YAGN,OAAO;gBACL,kBAAkB,CAAC,aAAa,GAAG,KAAK,IAAI;YAC9C;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1966, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1972, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs"],"sourcesContent":["import { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Input-Object-Field-Uniqueness\n */\nexport function UniqueInputFieldNamesRule(context) {\n  const knownNameStack = [];\n  let knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n\n      leave() {\n        const prevKnownNames = knownNameStack.pop();\n        prevKnownNames || invariant(false);\n        knownNames = prevKnownNames;\n      },\n    },\n\n    ObjectField(node) {\n      const fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one input field named \"${fieldName}\".`,\n            {\n              nodes: [knownNames[fieldName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAUO,SAAS,0BAA0B,OAAO;IAC/C,MAAM,iBAAiB,EAAE;IACzB,IAAI,aAAa,OAAO,MAAM,CAAC;IAC/B,OAAO;QACL,aAAa;YACX;gBACE,eAAe,IAAI,CAAC;gBACpB,aAAa,OAAO,MAAM,CAAC;YAC7B;YAEA;gBACE,MAAM,iBAAiB,eAAe,GAAG;gBACzC,kBAAkB,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;gBAC5B,aAAa;YACf;QACF;QAEA,aAAY,IAAI;YACd,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;YAEjC,IAAI,UAAU,CAAC,UAAU,EAAE;gBACzB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,yCAAyC,EAAE,UAAU,EAAE,CAAC,EACzD;oBACE,OAAO;wBAAC,UAAU,CAAC,UAAU;wBAAE,KAAK,IAAI;qBAAC;gBAC3C;YAGN,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,KAAK,IAAI;YACnC;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2009, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2015, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Operation-Name-Uniqueness\n */\nexport function UniqueOperationNamesRule(context) {\n  const knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition(node) {\n      const operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one operation named \"${operationName.value}\".`,\n              {\n                nodes: [\n                  knownOperationNames[operationName.value],\n                  operationName,\n                ],\n              },\n            ),\n          );\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n\n    FragmentDefinition: () => false,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AASO,SAAS,yBAAyB,OAAO;IAC9C,MAAM,sBAAsB,OAAO,MAAM,CAAC;IAC1C,OAAO;QACL,qBAAoB,IAAI;YACtB,MAAM,gBAAgB,KAAK,IAAI;YAE/B,IAAI,eAAe;gBACjB,IAAI,mBAAmB,CAAC,cAAc,KAAK,CAAC,EAAE;oBAC5C,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,uCAAuC,EAAE,cAAc,KAAK,CAAC,EAAE,CAAC,EACjE;wBACE,OAAO;4BACL,mBAAmB,CAAC,cAAc,KAAK,CAAC;4BACxC;yBACD;oBACH;gBAGN,OAAO;oBACL,mBAAmB,CAAC,cAAc,KAAK,CAAC,GAAG;gBAC7C;YACF;YAEA,OAAO;QACT;QAEA,oBAAoB,IAAM;IAC5B;AACF","ignoreList":[0]}},
    {"offset": {"line": 2042, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  const schema = context.getSchema();\n  const definedOperationTypes = Object.create(null);\n  const existingOperationTypes = schema\n    ? {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n      }\n    : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes,\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // See: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const operationTypesNodes =\n      (_node$operationTypes = node.operationTypes) !== null &&\n      _node$operationTypes !== void 0\n        ? _node$operationTypes\n        : [];\n\n    for (const operationType of operationTypesNodes) {\n      const operation = operationType.operation;\n      const alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(\n          new GraphQLError(\n            `Type for ${operation} already defined in the schema. It cannot be redefined.`,\n            {\n              nodes: operationType,\n            },\n          ),\n        );\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one ${operation} type in schema.`,\n            {\n              nodes: [alreadyDefinedOperationType, operationType],\n            },\n          ),\n        );\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,wBAAwB,OAAO,MAAM,CAAC;IAC5C,MAAM,yBAAyB,SAC3B;QACE,OAAO,OAAO,YAAY;QAC1B,UAAU,OAAO,eAAe;QAChC,cAAc,OAAO,mBAAmB;IAC1C,IACA,CAAC;IACL,OAAO;QACL,kBAAkB;QAClB,iBAAiB;IACnB;;IAEA,SAAS,oBAAoB,IAAI;QAC/B,IAAI;QAEJ,yDAAyD;QAEzD,kBAAkB,GAClB,MAAM,sBACJ,CAAC,uBAAuB,KAAK,cAAc,MAAM,QACjD,yBAAyB,KAAK,IAC1B,uBACA,EAAE;QAER,KAAK,MAAM,iBAAiB,oBAAqB;YAC/C,MAAM,YAAY,cAAc,SAAS;YACzC,MAAM,8BAA8B,qBAAqB,CAAC,UAAU;YAEpE,IAAI,sBAAsB,CAAC,UAAU,EAAE;gBACrC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,SAAS,EAAE,UAAU,uDAAuD,CAAC,EAC9E;oBACE,OAAO;gBACT;YAGN,OAAO,IAAI,6BAA6B;gBACtC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,sBAAsB,EAAE,UAAU,gBAAgB,CAAC,EACpD;oBACE,OAAO;wBAAC;wBAA6B;qBAAc;gBACrD;YAGN,OAAO;gBACL,qBAAqB,CAAC,UAAU,GAAG;YACrC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2091, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2097, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  const knownTypeNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName,\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(\n        new GraphQLError(\n          `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`,\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(\n        new GraphQLError(`There can be only one type named \"${typeName}\".`, {\n          nodes: [knownTypeNames[typeName], node.name],\n        }),\n      );\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,oBAAoB,OAAO;IACzC,MAAM,iBAAiB,OAAO,MAAM,CAAC;IACrC,MAAM,SAAS,QAAQ,SAAS;IAChC,OAAO;QACL,sBAAsB;QACtB,sBAAsB;QACtB,yBAAyB;QACzB,qBAAqB;QACrB,oBAAoB;QACpB,2BAA2B;IAC7B;;IAEA,SAAS,cAAc,IAAI;QACzB,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAEhC,IAAI,WAAW,QAAQ,WAAW,KAAK,KAAK,OAAO,OAAO,CAAC,WAAW;YACpE,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,MAAM,EAAE,SAAS,kFAAkF,CAAC,EACrG;gBACE,OAAO,KAAK,IAAI;YAClB;YAGJ;QACF;QAEA,IAAI,cAAc,CAAC,SAAS,EAAE;YAC5B,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CAAC,CAAC,kCAAkC,EAAE,SAAS,EAAE,CAAC,EAAE;gBAClE,OAAO;oBAAC,cAAc,CAAC,SAAS;oBAAE,KAAK,IAAI;iBAAC;YAC9C;QAEJ,OAAO;YACL,cAAc,CAAC,SAAS,GAAG,KAAK,IAAI;QACtC;QAEA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2135, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2141, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs"],"sourcesContent":["import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  return {\n    OperationDefinition(operationNode) {\n      var _operationNode$variab;\n\n      // See: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const variableDefinitions =\n        (_operationNode$variab = operationNode.variableDefinitions) !== null &&\n        _operationNode$variab !== void 0\n          ? _operationNode$variab\n          : [];\n      const seenVariableDefinitions = groupBy(\n        variableDefinitions,\n        (node) => node.variable.name.value,\n      );\n\n      for (const [variableName, variableNodes] of seenVariableDefinitions) {\n        if (variableNodes.length > 1) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one variable named \"$${variableName}\".`,\n              {\n                nodes: variableNodes.map((node) => node.variable.name),\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAOO,SAAS,wBAAwB,OAAO;IAC7C,OAAO;QACL,qBAAoB,aAAa;YAC/B,IAAI;YAEJ,yDAAyD;YAEzD,kBAAkB,GAClB,MAAM,sBACJ,CAAC,wBAAwB,cAAc,mBAAmB,MAAM,QAChE,0BAA0B,KAAK,IAC3B,wBACA,EAAE;YACR,MAAM,0BAA0B,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EACpC,qBACA,CAAC,OAAS,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;YAGpC,KAAK,MAAM,CAAC,cAAc,cAAc,IAAI,wBAAyB;gBACnE,IAAI,cAAc,MAAM,GAAG,GAAG;oBAC5B,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,uCAAuC,EAAE,aAAa,EAAE,CAAC,EAC1D;wBACE,OAAO,cAAc,GAAG,CAAC,CAAC,OAAS,KAAK,QAAQ,CAAC,IAAI;oBACvD;gBAGN;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2165, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2171, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/ValidationContext.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2344, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2350, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  getNullableType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isRequiredInputField,\n} from '../../type/definition.mjs';\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          const typeStr = inspect(fieldDef.type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = getNamedType(context.getParentInputType());\n      const fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        const suggestions = suggestionList(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `Expected value of type \"${inspect(type)}\", found ${print(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    const typeStr = inspect(locationType);\n    context.reportError(\n      new GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = inspect(locationType);\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}; ` +\n            error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2458, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2464, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isInputType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n *\n * See https://spec.graphql.org/draft/#sec-Variables-Are-Input-Types\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.type);\n\n      if (type !== undefined && !isInputType(type)) {\n        const variableName = node.variable.name.value;\n        const typeName = print(node.type);\n        context.reportError(\n          new GraphQLError(\n            `Variable \"$${variableName}\" cannot be non-input type \"${typeName}\".`,\n            {\n              nodes: node.type,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAGA;AADA;AADA;AADA;;;;;AAaO,SAAS,2BAA2B,OAAO;IAChD,OAAO;QACL,oBAAmB,IAAI;YACrB,MAAM,OAAO,CAAA,GAAA,yMAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI,KAAK,IAAI;YAEvD,IAAI,SAAS,aAAa,CAAC,CAAA,GAAA,mMAAA,CAAA,cAAW,AAAD,EAAE,OAAO;gBAC5C,MAAM,eAAe,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;gBAC7C,MAAM,WAAW,CAAA,GAAA,oMAAA,CAAA,QAAK,AAAD,EAAE,KAAK,IAAI;gBAChC,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,WAAW,EAAE,aAAa,4BAA4B,EAAE,SAAS,EAAE,CAAC,EACrE;oBACE,OAAO,KAAK,IAAI;gBAClB;YAGN;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2489, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2495, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isNonNullType } from '../../type/definition.mjs';\nimport { isTypeSubTypeOf } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables in allowed position\n *\n * Variable usages must be compatible with the arguments they are passed to.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed\n */\nexport function VariablesInAllowedPositionRule(context) {\n  let varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        varDefMap = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node, type, defaultValue } of usages) {\n          const varName = node.name.value;\n          const varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            const schema = context.getSchema();\n            const varType = typeFromAST(schema, varDef.type);\n\n            if (\n              varType &&\n              !allowedVariableUsage(\n                schema,\n                varType,\n                varDef.defaultValue,\n                type,\n                defaultValue,\n              )\n            ) {\n              const varTypeStr = inspect(varType);\n              const typeStr = inspect(type);\n              context.reportError(\n                new GraphQLError(\n                  `Variable \"$${varName}\" of type \"${varTypeStr}\" used in position expecting type \"${typeStr}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    },\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(\n  schema,\n  varType,\n  varDefaultValue,\n  locationType,\n  locationDefaultValue,\n) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    const hasNonNullVariableDefaultValue =\n      varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    const hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    const nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n"],"names":[],"mappings":";;;AAKA;AALA;AACA;AAEA;AACA;AAFA;;;;;;;AAYO,SAAS,+BAA+B,OAAO;IACpD,IAAI,YAAY,OAAO,MAAM,CAAC;IAC9B,OAAO;QACL,qBAAqB;YACnB;gBACE,YAAY,OAAO,MAAM,CAAC;YAC5B;YAEA,OAAM,SAAS;gBACb,MAAM,SAAS,QAAQ,0BAA0B,CAAC;gBAElD,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,OAAQ;oBACjD,MAAM,UAAU,KAAK,IAAI,CAAC,KAAK;oBAC/B,MAAM,SAAS,SAAS,CAAC,QAAQ;oBAEjC,IAAI,UAAU,MAAM;wBAClB,kEAAkE;wBAClE,iEAAiE;wBACjE,oEAAoE;wBACpE,oEAAoE;wBACpE,+CAA+C;wBAC/C,MAAM,SAAS,QAAQ,SAAS;wBAChC,MAAM,UAAU,CAAA,GAAA,yMAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,OAAO,IAAI;wBAE/C,IACE,WACA,CAAC,qBACC,QACA,SACA,OAAO,YAAY,EACnB,MACA,eAEF;4BACA,MAAM,aAAa,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE;4BAC3B,MAAM,UAAU,CAAA,GAAA,mMAAA,CAAA,UAAO,AAAD,EAAE;4BACxB,QAAQ,WAAW,CACjB,IAAI,sMAAA,CAAA,eAAY,CACd,CAAC,WAAW,EAAE,QAAQ,WAAW,EAAE,WAAW,mCAAmC,EAAE,QAAQ,EAAE,CAAC,EAC9F;gCACE,OAAO;oCAAC;oCAAQ;iCAAK;4BACvB;wBAGN;oBACF;gBACF;YACF;QACF;QAEA,oBAAmB,IAAI;YACrB,SAAS,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QACxC;IACF;AACF;AACA;;;;CAIC,GAED,SAAS,qBACP,MAAM,EACN,OAAO,EACP,eAAe,EACf,YAAY,EACZ,oBAAoB;IAEpB,IAAI,CAAA,GAAA,mMAAA,CAAA,gBAAa,AAAD,EAAE,iBAAiB,CAAC,CAAA,GAAA,mMAAA,CAAA,gBAAa,AAAD,EAAE,UAAU;QAC1D,MAAM,iCACJ,mBAAmB,QAAQ,gBAAgB,IAAI,KAAK,kMAAA,CAAA,OAAI,CAAC,IAAI;QAC/D,MAAM,0BAA0B,yBAAyB;QAEzD,IAAI,CAAC,kCAAkC,CAAC,yBAAyB;YAC/D,OAAO;QACT;QAEA,MAAM,uBAAuB,aAAa,MAAM;QAChD,OAAO,CAAA,GAAA,6MAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ,SAAS;IAC1C;IAEA,OAAO,CAAA,GAAA,6MAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ,SAAS;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 2565, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2571, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/specifiedRules.mjs"],"sourcesContent":["// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from './rules/ExecutableDefinitionsRule.mjs'; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from './rules/FieldsOnCorrectTypeRule.mjs'; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from './rules/FragmentsOnCompositeTypesRule.mjs'; // Spec Section: \"Argument Names\"\n\nimport {\n  KnownArgumentNamesOnDirectivesRule,\n  KnownArgumentNamesRule,\n} from './rules/KnownArgumentNamesRule.mjs'; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from './rules/KnownDirectivesRule.mjs'; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from './rules/KnownFragmentNamesRule.mjs'; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from './rules/KnownTypeNamesRule.mjs'; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from './rules/LoneAnonymousOperationRule.mjs'; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from './rules/LoneSchemaDefinitionRule.mjs'; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from './rules/NoFragmentCyclesRule.mjs'; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from './rules/NoUndefinedVariablesRule.mjs'; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from './rules/NoUnusedFragmentsRule.mjs'; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from './rules/NoUnusedVariablesRule.mjs'; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from './rules/OverlappingFieldsCanBeMergedRule.mjs'; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from './rules/PossibleFragmentSpreadsRule.mjs';\nimport { PossibleTypeExtensionsRule } from './rules/PossibleTypeExtensionsRule.mjs'; // Spec Section: \"Argument Optionality\"\n\nimport {\n  ProvidedRequiredArgumentsOnDirectivesRule,\n  ProvidedRequiredArgumentsRule,\n} from './rules/ProvidedRequiredArgumentsRule.mjs'; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from './rules/ScalarLeafsRule.mjs'; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from './rules/SingleFieldSubscriptionsRule.mjs';\nimport { UniqueArgumentDefinitionNamesRule } from './rules/UniqueArgumentDefinitionNamesRule.mjs'; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from './rules/UniqueArgumentNamesRule.mjs';\nimport { UniqueDirectiveNamesRule } from './rules/UniqueDirectiveNamesRule.mjs'; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from './rules/UniqueDirectivesPerLocationRule.mjs';\nimport { UniqueEnumValueNamesRule } from './rules/UniqueEnumValueNamesRule.mjs';\nimport { UniqueFieldDefinitionNamesRule } from './rules/UniqueFieldDefinitionNamesRule.mjs'; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from './rules/UniqueFragmentNamesRule.mjs'; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from './rules/UniqueInputFieldNamesRule.mjs'; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from './rules/UniqueOperationNamesRule.mjs';\nimport { UniqueOperationTypesRule } from './rules/UniqueOperationTypesRule.mjs';\nimport { UniqueTypeNamesRule } from './rules/UniqueTypeNamesRule.mjs'; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from './rules/UniqueVariableNamesRule.mjs'; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from './rules/ValuesOfCorrectTypeRule.mjs'; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from './rules/VariablesAreInputTypesRule.mjs'; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from './rules/VariablesInAllowedPositionRule.mjs';\n\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\nexport const specifiedRules = Object.freeze([\n  ExecutableDefinitionsRule,\n  UniqueOperationNamesRule,\n  LoneAnonymousOperationRule,\n  SingleFieldSubscriptionsRule,\n  KnownTypeNamesRule,\n  FragmentsOnCompositeTypesRule,\n  VariablesAreInputTypesRule,\n  ScalarLeafsRule,\n  FieldsOnCorrectTypeRule,\n  UniqueFragmentNamesRule,\n  KnownFragmentNamesRule,\n  NoUnusedFragmentsRule,\n  PossibleFragmentSpreadsRule,\n  NoFragmentCyclesRule,\n  UniqueVariableNamesRule,\n  NoUndefinedVariablesRule,\n  NoUnusedVariablesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  KnownArgumentNamesRule,\n  UniqueArgumentNamesRule,\n  ValuesOfCorrectTypeRule,\n  ProvidedRequiredArgumentsRule,\n  VariablesInAllowedPositionRule,\n  OverlappingFieldsCanBeMergedRule,\n  UniqueInputFieldNamesRule,\n]);\n/**\n * @internal\n */\n\nexport const specifiedSDLRules = Object.freeze([\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueArgumentDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  KnownArgumentNamesOnDirectivesRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule,\n  ProvidedRequiredArgumentsOnDirectivesRule,\n]);\n"],"names":[],"mappings":"AAAA,yCAAyC;;;;;AACzC,wYAAmF,4EAA4E;AAuD/J;AAtCA,0YAAqF,gCAAgC;AAwBrH;AA1BA,0XAAqE,2CAA2C;AAXhH,gZAA2F,iCAAiC;AA2D5H,0YAAqF,kDAAkD;AAxBvI,oXAA+D,uDAAuD;AArCtH,oYAA+E,+CAA+C;AAiD9H,oYAA+E,gDAAgD;AAtC/H,kYAA6E,iDAAiD;AAY9H,gYAA2E,qCAAqC;AAMhH;AAVA,8XAAyE,4CAA4C;AAsCrH,oYAA+E,yCAAyC;AApCxH,sYAAiF,yCAAyC;AAI1H,gYAA2E,0CAA0C;AAhBrH,4XAAuE,iDAAiD;AAoCxH;AAzCA,kYAG6C,yCAAyC;AAmCtF;AAiBA,oYAA+E,4CAA4C;AA3B3H,gZAGoD,wCAAwC;AA4B5F;AApCA,sZAAiG,8CAA8C;AAwB/I,wYAAmF,4CAA4C;AAlC/H,sYAAiF,iDAAiD;AAqClI;AACA,4XAAuE,sCAAsC;AAT7G;AACA,kZAA6F,2CAA2C;AAPxI,wZAAmG,sCAAsC;AAGzI,sYAAiF,qDAAqD;AAbtI,0YAAqF,uCAAuC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCrH,MAAM,iBAAiB,OAAO,MAAM,CAAC;IAC1C,iOAAA,CAAA,4BAAyB;IACzB,gOAAA,CAAA,2BAAwB;IACxB,kOAAA,CAAA,6BAA0B;IAC1B,oOAAA,CAAA,+BAA4B;IAC5B,0NAAA,CAAA,qBAAkB;IAClB,qOAAA,CAAA,gCAA6B;IAC7B,kOAAA,CAAA,6BAA0B;IAC1B,uNAAA,CAAA,kBAAe;IACf,+NAAA,CAAA,0BAAuB;IACvB,+NAAA,CAAA,0BAAuB;IACvB,8NAAA,CAAA,yBAAsB;IACtB,6NAAA,CAAA,wBAAqB;IACrB,mOAAA,CAAA,8BAA2B;IAC3B,4NAAA,CAAA,uBAAoB;IACpB,+NAAA,CAAA,0BAAuB;IACvB,gOAAA,CAAA,2BAAwB;IACxB,6NAAA,CAAA,wBAAqB;IACrB,2NAAA,CAAA,sBAAmB;IACnB,uOAAA,CAAA,kCAA+B;IAC/B,8NAAA,CAAA,yBAAsB;IACtB,+NAAA,CAAA,0BAAuB;IACvB,+NAAA,CAAA,0BAAuB;IACvB,qOAAA,CAAA,gCAA6B;IAC7B,sOAAA,CAAA,iCAA8B;IAC9B,wOAAA,CAAA,mCAAgC;IAChC,iOAAA,CAAA,4BAAyB;CAC1B;AAKM,MAAM,oBAAoB,OAAO,MAAM,CAAC;IAC7C,gOAAA,CAAA,2BAAwB;IACxB,gOAAA,CAAA,2BAAwB;IACxB,2NAAA,CAAA,sBAAmB;IACnB,gOAAA,CAAA,2BAAwB;IACxB,sOAAA,CAAA,iCAA8B;IAC9B,yOAAA,CAAA,oCAAiC;IACjC,gOAAA,CAAA,2BAAwB;IACxB,0NAAA,CAAA,qBAAkB;IAClB,2NAAA,CAAA,sBAAmB;IACnB,uOAAA,CAAA,kCAA+B;IAC/B,kOAAA,CAAA,6BAA0B;IAC1B,8NAAA,CAAA,qCAAkC;IAClC,+NAAA,CAAA,0BAAuB;IACvB,iOAAA,CAAA,4BAAyB;IACzB,qOAAA,CAAA,4CAAyC;CAC1C","ignoreList":[0]}},
    {"offset": {"line": 2689, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2695, "column": 0}, "map": {"version":3,"sources":["file:///Users/benjaminshafii/git/hypr-v0/packages/request-invoice-web/node_modules/.pnpm/graphql%4016.8.1/node_modules/graphql/validation/validate.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport {\n  SDLValidationContext,\n  ValidationContext,\n} from './ValidationContext.mjs';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(\n  schema,\n  documentAST,\n  rules = specifiedRules,\n  options,\n  /** @deprecated will be removed in 17.0.0 */\n  typeInfo = new TypeInfo(schema),\n) {\n  var _options$maxErrors;\n\n  const maxErrors =\n    (_options$maxErrors =\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\n      null && _options$maxErrors !== void 0\n      ? _options$maxErrors\n      : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(\n    schema,\n    documentAST,\n    typeInfo,\n    (error) => {\n      if (errors.length >= maxErrors) {\n        errors.push(\n          new GraphQLError(\n            'Too many validation errors, error limit reached. Validation aborted.',\n          ),\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n        throw abortObj;\n      }\n\n      errors.push(error);\n    },\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map((rule) => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(\n  documentAST,\n  schemaToExtend,\n  rules = specifiedSDLRules,\n) {\n  const errors = [];\n  const context = new SDLValidationContext(\n    documentAST,\n    schemaToExtend,\n    (error) => {\n      errors.push(error);\n    },\n  );\n  const visitors = rules.map((rule) => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n"],"names":[],"mappings":";;;;;;AAKA;AADA;AAJA;AAGA;AAGA;AALA;AACA;;;;;;;;AA6BO,SAAS,SACd,MAAM,EACN,WAAW,EACX,QAAQ,6MAAA,CAAA,iBAAc,EACtB,OAAO,EACP,0CAA0C,GAC1C,WAAW,IAAI,sMAAA,CAAA,WAAQ,CAAC,OAAO;IAE/B,IAAI;IAEJ,MAAM,YACJ,CAAC,qBACC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,SAAS,MACnE,QAAQ,uBAAuB,KAAK,IAClC,qBACA;IACN,eAAe,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE,OAAO,2BAA2B,gEAAgE;IAE3H,CAAA,GAAA,iMAAA,CAAA,oBAAiB,AAAD,EAAE;IAClB,MAAM,WAAW,OAAO,MAAM,CAAC,CAAC;IAChC,MAAM,SAAS,EAAE;IACjB,MAAM,UAAU,IAAI,gNAAA,CAAA,oBAAiB,CACnC,QACA,aACA,UACA,CAAC;QACC,IAAI,OAAO,MAAM,IAAI,WAAW;YAC9B,OAAO,IAAI,CACT,IAAI,sMAAA,CAAA,eAAY,CACd,0EAED,+DAA+D;YAElE,MAAM;QACR;QAEA,OAAO,IAAI,CAAC;IACd,IACC,4EAA4E;IAC/E,oDAAoD;IAEpD,MAAM,UAAU,CAAA,GAAA,oMAAA,CAAA,kBAAe,AAAD,EAAE,MAAM,GAAG,CAAC,CAAC,OAAS,KAAK,YAAY,qEAAqE;IAE1I,IAAI;QACF,CAAA,GAAA,oMAAA,CAAA,QAAK,AAAD,EAAE,aAAa,CAAA,GAAA,sMAAA,CAAA,oBAAiB,AAAD,EAAE,UAAU;IACjD,EAAE,OAAO,GAAG;QACV,IAAI,MAAM,UAAU;YAClB,MAAM;QACR;IACF;IAEA,OAAO;AACT;AAKO,SAAS,YACd,WAAW,EACX,cAAc,EACd,QAAQ,6MAAA,CAAA,oBAAiB;IAEzB,MAAM,SAAS,EAAE;IACjB,MAAM,UAAU,IAAI,gNAAA,CAAA,uBAAoB,CACtC,aACA,gBACA,CAAC;QACC,OAAO,IAAI,CAAC;IACd;IAEF,MAAM,WAAW,MAAM,GAAG,CAAC,CAAC,OAAS,KAAK;IAC1C,CAAA,GAAA,oMAAA,CAAA,QAAK,AAAD,EAAE,aAAa,CAAA,GAAA,oMAAA,CAAA,kBAAe,AAAD,EAAE;IACnC,OAAO;AACT;AAQO,SAAS,eAAe,WAAW;IACxC,MAAM,SAAS,YAAY;IAE3B,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAAE,IAAI,CAAC;IAC5D;AACF;AAQO,SAAS,wBAAwB,WAAW,EAAE,MAAM;IACzD,MAAM,SAAS,YAAY,aAAa;IAExC,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAAE,IAAI,CAAC;IAC5D;AACF","ignoreList":[0]}},
    {"offset": {"line": 2761, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}